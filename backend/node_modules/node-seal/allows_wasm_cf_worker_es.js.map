{"version":3,"file":"allows_wasm_cf_worker_es.js","sources":["../src/bin/seal_allows_wasm_cf_worker.js","../src/implementation/constants.ts","../src/implementation/batch-encoder.ts","../src/implementation/cipher-text.ts","../src/implementation/ckks-encoder.ts","../src/implementation/coeff-modulus.ts","../src/implementation/compr-mode-type.ts","../src/implementation/context.ts","../src/implementation/context-data.ts","../src/implementation/decryptor.ts","../src/implementation/encryption-parameters.ts","../src/implementation/encryptor.ts","../src/implementation/evaluator.ts","../src/implementation/exception.ts","../src/implementation/galois-keys.ts","../src/implementation/key-generator.ts","../src/implementation/memory-pool-handle.ts","../src/implementation/modulus.ts","../src/implementation/parms-id-type.ts","../src/implementation/plain-modulus.ts","../src/implementation/plain-text.ts","../src/implementation/public-key.ts","../src/implementation/relin-keys.ts","../src/implementation/scheme-type.ts","../src/implementation/seal.ts","../src/implementation/secret-key.ts","../src/implementation/security-level.ts","../src/implementation/vector.ts","../src/allows_wasm_cf_worker_es.ts","../src/main/seal.ts","../src/implementation/encryption-parameter-qualifiers.ts","../src/implementation/serializable.ts"],"sourcesContent":["var Module = (() => {\n  \n  return (\nasync function(moduleArg = {}) {\n  var moduleRtn;\n\nvar k=moduleArg,aa,ba,ca=new Promise((a,b)=>{aa=a;ba=b}),da=\"./this.program\",ea=import.meta.url,fa=\"\",ha,ia;try{fa=(new URL(\".\",ea)).href}catch{}ia=a=>{var b=new XMLHttpRequest;b.open(\"GET\",a,!1);b.responseType=\"arraybuffer\";b.send(null);return new Uint8Array(b.response)};ha=async a=>{a=await fetch(a,{credentials:\"same-origin\"});if(a.ok)return a.arrayBuffer();throw Error(a.status+\" : \"+a.url);};var q=console.error.bind(console),u,w,y=!1,ja,ka,z,A,B,D,E,la,ma,na,oa;\nfunction pa(){var a=w.buffer;ka=new Int8Array(a);A=new Int16Array(a);z=new Uint8Array(a);B=new Uint16Array(a);D=new Int32Array(a);E=new Uint32Array(a);la=new Float32Array(a);oa=new Float64Array(a);ma=new BigInt64Array(a);na=new BigUint64Array(a)}var G=0,I=null;function qa(a){k.onAbort?.(a);a=\"Aborted(\"+a+\")\";q(a);y=!0;a=new WebAssembly.RuntimeError(a+\". Build with -sASSERTIONS for more info.\");ba(a);throw a;}var ra;\nasync function sa(a){if(!u)try{var b=await ha(a);return new Uint8Array(b)}catch{}if(a==ra&&u)a=new Uint8Array(u);else if(ia)a=ia(a);else throw\"both async and sync fetching of the wasm failed\";return a}async function ta(a,b){try{var c=await sa(a);return await WebAssembly.instantiate(c,b)}catch(d){q(`failed to asynchronously prepare wasm: ${d}`),qa(d)}}\nasync function ua(a){var b=ra;if(!u&&\"function\"==typeof WebAssembly.instantiateStreaming)try{var c=fetch(b,{credentials:\"same-origin\"});return await WebAssembly.instantiateStreaming(c,a)}catch(d){q(`wasm streaming compile failed: ${d}`),q(\"falling back to ArrayBuffer instantiation\")}return ta(b,a)}class va{name=\"ExitStatus\";constructor(a){this.message=`Program terminated with exit(${a})`;this.status=a}}\nvar wa=a=>{for(;0<a.length;)a.shift()(k)},xa=[],ya=[],za=()=>{var a=k.preRun.shift();ya.push(a)},Aa=!0;class Ba{constructor(a){this.X=a-24}}var Ca=0,Da=0,Ea,J=a=>{for(var b=\"\";z[a>>>0];)b+=Ea[z[a++>>>0]];return b},K={},L={},Fa={},M=class extends Error{constructor(a){super(a);this.name=\"BindingError\"}};\nfunction Ga(a,b,c={}){var d=b.name;if(!a)throw new M(`type \"${d}\" must have a positive integer typeid pointer`);if(L.hasOwnProperty(a)){if(c.va)return;throw new M(`Cannot register type '${d}' twice`);}L[a]=b;delete Fa[a];K.hasOwnProperty(a)&&(b=K[a],delete K[a],b.forEach(e=>e()))}function N(a,b,c={}){return Ga(a,b,c)}\nvar Ha=(a,b,c)=>{switch(b){case 1:return c?d=>ka[d>>>0]:d=>z[d>>>0];case 2:return c?d=>A[d>>>1>>>0]:d=>B[d>>>1>>>0];case 4:return c?d=>D[d>>>2>>>0]:d=>E[d>>>2>>>0];case 8:return c?d=>ma[d>>>3>>>0]:d=>na[d>>>3>>>0];default:throw new TypeError(`invalid integer width (${b}): ${a}`);}},Ja=a=>{throw new M(a.V.Y.W.name+\" instance already deleted\");},Ka=!1,La=()=>{},P=a=>{if(\"undefined\"===typeof FinalizationRegistry)return P=b=>b,a;Ka=new FinalizationRegistry(b=>{b=b.V;--b.count.value;0===b.count.value&&\n(b.$?b.ba.fa(b.$):b.Y.W.fa(b.X))});P=b=>{var c=b.V;c.$&&Ka.register(b,{V:c},b);return b};La=b=>{Ka.unregister(b)};return P(a)},Ma=[];function Na(){}\nvar Oa=(a,b)=>Object.defineProperty(b,\"name\",{value:a}),Pa={},Qa=(a,b,c)=>{if(void 0===a[b].Z){var d=a[b];a[b]=function(...e){if(!a[b].Z.hasOwnProperty(e.length))throw new M(`Function '${c}' called with an invalid number of arguments (${e.length}) - expects one of (${a[b].Z})!`);return a[b].Z[e.length].apply(this,e)};a[b].Z=[];a[b].Z[d.ga]=d}},Ra=(a,b,c)=>{if(k.hasOwnProperty(a)){if(void 0===c||void 0!==k[a].Z&&void 0!==k[a].Z[c])throw new M(`Cannot register public name '${a}' twice`);Qa(k,a,a);if(k[a].Z.hasOwnProperty(c))throw new M(`Cannot register multiple overloads of a function with the same number of arguments (${c})!`);\nk[a].Z[c]=b}else k[a]=b,k[a].ga=c},Sa=a=>{a=a.replace(/[^a-zA-Z0-9_]/g,\"$\");var b=a.charCodeAt(0);return 48<=b&&57>=b?`_${a}`:a};function Ta(a,b,c,d,e,f,h,g){this.name=a;this.constructor=b;this.ea=c;this.fa=d;this.aa=e;this.ta=f;this.ka=h;this.sa=g;this.xa=[]}\nvar Ua=(a,b,c)=>{for(;b!==c;){if(!b.ka)throw new M(`Expected null or instance of ${c.name}, got an instance of ${b.name}`);a=b.ka(a);b=b.aa}return a},Va=a=>{if(null===a)return\"null\";var b=typeof a;return\"object\"===b||\"array\"===b||\"function\"===b?a.toString():\"\"+a};\nfunction Wa(a,b){if(null===b){if(this.oa)throw new M(`null is not a valid ${this.name}`);return 0}if(!b.V)throw new M(`Cannot pass \"${Va(b)}\" as a ${this.name}`);if(!b.V.X)throw new M(`Cannot pass deleted object as a pointer of type ${this.name}`);return Ua(b.V.X,b.V.Y.W,this.W)}\nfunction Xa(a,b){if(null===b){if(this.oa)throw new M(`null is not a valid ${this.name}`);if(this.na){var c=this.ya();null!==a&&a.push(this.fa,c);return c}return 0}if(!b||!b.V)throw new M(`Cannot pass \"${Va(b)}\" as a ${this.name}`);if(!b.V.X)throw new M(`Cannot pass deleted object as a pointer of type ${this.name}`);if(!this.ma&&b.V.Y.ma)throw new M(`Cannot convert argument of type ${b.V.ba?b.V.ba.name:b.V.Y.name} to parameter type ${this.name}`);c=Ua(b.V.X,b.V.Y.W,this.W);if(this.na){if(void 0===\nb.V.$)throw new M(\"Passing raw pointer to smart pointer is illegal\");switch(this.Aa){case 0:if(b.V.ba===this)c=b.V.$;else throw new M(`Cannot convert argument of type ${b.V.ba?b.V.ba.name:b.V.Y.name} to parameter type ${this.name}`);break;case 1:c=b.V.$;break;case 2:if(b.V.ba===this)c=b.V.$;else{var d=b.clone();c=this.za(c,Q(()=>d[\"delete\"]()));null!==a&&a.push(this.fa,c)}break;default:throw new M(\"Unsupporting sharing policy\");}}return c}\nfunction Ya(a,b){if(null===b){if(this.oa)throw new M(`null is not a valid ${this.name}`);return 0}if(!b.V)throw new M(`Cannot pass \"${Va(b)}\" as a ${this.name}`);if(!b.V.X)throw new M(`Cannot pass deleted object as a pointer of type ${this.name}`);if(b.V.Y.ma)throw new M(`Cannot convert argument of type ${b.V.Y.name} to parameter type ${this.name}`);return Ua(b.V.X,b.V.Y.W,this.W)}function Za(a){return this.fromWireType(E[a>>>2>>>0])}\nvar $a=(a,b,c)=>{if(b===c)return a;if(void 0===c.aa)return null;a=$a(a,b,c.aa);return null===a?null:c.sa(a)},ab={},bb=(a,b)=>{if(void 0===b)throw new M(\"ptr should not be undefined\");for(;a.aa;)b=a.ka(b),a=a.aa;return ab[b]},cb=class extends Error{constructor(a){super(a);this.name=\"InternalError\"}},db=(a,b)=>{if(!b.Y||!b.X)throw new cb(\"makeClassHandle requires ptr and ptrType\");if(!!b.ba!==!!b.$)throw new cb(\"Both smartPtrType and smartPtr must be specified\");b.count={value:1};return P(Object.create(a,\n{V:{value:b,writable:!0}}))};function eb(a,b,c,d,e,f,h,g,l,n,m){this.name=a;this.W=b;this.oa=c;this.ma=d;this.na=e;this.wa=f;this.Aa=h;this.qa=g;this.ya=l;this.za=n;this.fa=m;e||void 0!==b.aa?this.toWireType=Xa:(this.toWireType=d?Wa:Ya,this.da=null)}\nvar fb=(a,b,c)=>{if(!k.hasOwnProperty(a))throw new cb(\"Replacing nonexistent public symbol\");void 0!==k[a].Z&&void 0!==c?k[a].Z[c]=b:(k[a]=b,k[a].ga=c)},gb=[],hb,ib=a=>{var b=gb[a];b||(gb[a]=b=hb.get(a));return b},jb=(a,b,c=[])=>{b=ib(b)(...c);return\"p\"==a[0]?b>>>0:b},kb=(a,b)=>(...c)=>jb(a,b,c),R=(a,b)=>{a=J(a);var c=a.includes(\"p\")?kb(a,b):ib(b);if(\"function\"!=typeof c)throw new M(`unknown function pointer with signature ${a}: ${b}`);return c};class lb extends Error{}\nvar nb=a=>{a=mb(a);var b=J(a);S(a);return b},T=(a,b)=>{function c(f){e[f]||L[f]||(Fa[f]?Fa[f].forEach(c):(d.push(f),e[f]=!0))}var d=[],e={};b.forEach(c);throw new lb(`${a}: `+d.map(nb).join([\", \"]));},U=(a,b,c)=>{function d(g){g=c(g);if(g.length!==a.length)throw new cb(\"Mismatched type converter count\");for(var l=0;l<a.length;++l)N(a[l],g[l])}a.forEach(g=>Fa[g]=b);var e=Array(b.length),f=[],h=0;b.forEach((g,l)=>{L.hasOwnProperty(g)?e[l]=L[g]:(f.push(g),K.hasOwnProperty(g)||(K[g]=[]),K[g].push(()=>\n{e[l]=L[g];++h;h===f.length&&d(e)}))});0===f.length&&d(e)},ob=a=>{for(;a.length;){var b=a.pop();a.pop()(b)}};function pb(a){for(var b=1;b<a.length;++b)if(null!==a[b]&&void 0===a[b].da)return!0;return!1}\nfunction qb(a,b,c,d,e){var f=b.length;if(2>f)throw new M(\"argTypes array size mismatch! Must at least get return value and 'this' types!\");var h=null!==b[1]&&null!==c,g=pb(b),l=\"void\"!==b[0].name,n=f-2,m=Array(n),p=[],r=[];return Oa(a,function(...x){r.length=0;p.length=h?2:1;p[0]=e;if(h){var t=b[1].toWireType(r,this);p[1]=t}for(var v=0;v<n;++v)m[v]=b[v+2].toWireType(r,x[v]),p.push(m[v]);x=d(...p);if(g)ob(r);else for(v=h?1:2;v<b.length;v++){var F=1===v?t:m[v-2];null!==b[v].da&&b[v].da(F)}t=l?b[0].fromWireType(x):\nvoid 0;return t})}\nvar rb=(a,b)=>{for(var c=[],d=0;d<a;d++)c.push(E[b+4*d>>>2>>>0]);return c},tb=a=>{a=a.trim();const b=a.indexOf(\"(\");return-1===b?a:a.slice(0,b)},ub=(a,b,c)=>{if(!(a instanceof Object))throw new M(`${c} with invalid \"this\": ${a}`);if(!(a instanceof b.W.constructor))throw new M(`${c} incompatible with \"this\" of type ${a.constructor.name}`);if(!a.V.X)throw new M(`cannot call emscripten binding method ${c} on deleted object`);return Ua(a.V.X,a.V.Y.W,b.W)},vb=[],V=[0,1,,1,null,1,!0,1,!1,1];\nfunction wb(a){a>>>=0;9<a&&0===--V[a+1]&&(V[a]=void 0,vb.push(a))}\nfor(var W=a=>{if(!a)throw new M(`Cannot use deleted val. handle = ${a}`);return V[a]},Q=a=>{switch(a){case void 0:return 2;case null:return 4;case !0:return 6;case !1:return 8;default:const b=vb.pop()||V.length;V[b]=a;V[b+1]=1;return b}},xb={name:\"emscripten::val\",fromWireType:a=>{var b=W(a);wb(a);return b},toWireType:(a,b)=>Q(b),ca:8,readValueFromPointer:Za,da:null},yb=(a,b,c)=>{switch(b){case 1:return c?function(d){return this.fromWireType(ka[d>>>0])}:function(d){return this.fromWireType(z[d>>>\n0])};case 2:return c?function(d){return this.fromWireType(A[d>>>1>>>0])}:function(d){return this.fromWireType(B[d>>>1>>>0])};case 4:return c?function(d){return this.fromWireType(D[d>>>2>>>0])}:function(d){return this.fromWireType(E[d>>>2>>>0])};default:throw new TypeError(`invalid integer width (${b}): ${a}`);}},zb=(a,b)=>{var c=L[a];if(void 0===c)throw a=`${b} has unknown type ${nb(a)}`,new M(a);return c},Ab=(a,b)=>{switch(b){case 4:return function(c){return this.fromWireType(la[c>>>2>>>0])};case 8:return function(c){return this.fromWireType(oa[c>>>\n3>>>0])};default:throw new TypeError(`invalid float width (${b}): ${a}`);}},Bb=Object.assign({optional:!0},xb),X=(a,b,c)=>{var d=z;b>>>=0;if(!(0<c))return 0;var e=b;c=b+c-1;for(var f=0;f<a.length;++f){var h=a.charCodeAt(f);if(55296<=h&&57343>=h){var g=a.charCodeAt(++f);h=65536+((h&1023)<<10)|g&1023}if(127>=h){if(b>=c)break;d[b++>>>0]=h}else{if(2047>=h){if(b+1>=c)break;d[b++>>>0]=192|h>>6}else{if(65535>=h){if(b+2>=c)break;d[b++>>>0]=224|h>>12}else{if(b+3>=c)break;d[b++>>>0]=240|h>>18;d[b++>>>0]=128|\nh>>12&63}d[b++>>>0]=128|h>>6&63}d[b++>>>0]=128|h&63}}d[b>>>0]=0;return b-e},Cb=a=>{for(var b=0,c=0;c<a.length;++c){var d=a.charCodeAt(c);127>=d?b++:2047>=d?b+=2:55296<=d&&57343>=d?(b+=4,++c):b+=3}return b},Db=\"undefined\"!=typeof TextDecoder?new TextDecoder:void 0,Eb=(a=0,b=NaN)=>{var c=z;a>>>=0;var d=a+b;for(b=a;c[b]&&!(b>=d);)++b;if(16<b-a&&c.buffer&&Db)return Db.decode(c.subarray(a,b));for(d=\"\";a<b;){var e=c[a++];if(e&128){var f=c[a++]&63;if(192==(e&224))d+=String.fromCharCode((e&31)<<6|f);else{var h=\nc[a++]&63;e=224==(e&240)?(e&15)<<12|f<<6|h:(e&7)<<18|f<<12|h<<6|c[a++]&63;65536>e?d+=String.fromCharCode(e):(e-=65536,d+=String.fromCharCode(55296|e>>10,56320|e&1023))}}else d+=String.fromCharCode(e)}return d},Fb=\"undefined\"!=typeof TextDecoder?new TextDecoder(\"utf-16le\"):void 0,Gb=(a,b)=>{a>>>=1;b=a+b/2;for(var c=a;!(c>=b)&&B[c>>>0];)++c;if(16<c-a&&Fb)return Fb.decode(B.subarray(a>>>0,c>>>0));for(c=\"\";!(a>=b);++a){var d=B[a>>>0];if(0==d)break;c+=String.fromCharCode(d)}return c},Hb=(a,b,c)=>{c??=\n2147483647;if(2>c)return 0;c-=2;var d=b;c=c<2*a.length?c/2:a.length;for(var e=0;e<c;++e)A[b>>>1>>>0]=a.charCodeAt(e),b+=2;A[b>>>1>>>0]=0;return b-d},Ib=a=>2*a.length,Jb=(a,b)=>{for(var c=0,d=\"\";!(c>=b/4);){var e=D[a+4*c>>>2>>>0];if(0==e)break;++c;65536<=e?(e-=65536,d+=String.fromCharCode(55296|e>>10,56320|e&1023)):d+=String.fromCharCode(e)}return d},Kb=(a,b,c)=>{b>>>=0;c??=2147483647;if(4>c)return 0;var d=b;c=d+c-4;for(var e=0;e<a.length;++e){var f=a.charCodeAt(e);if(55296<=f&&57343>=f){var h=a.charCodeAt(++e);\nf=65536+((f&1023)<<10)|h&1023}D[b>>>2>>>0]=f;b+=4;if(b+4>c)break}D[b>>>2>>>0]=0;return b-d},Lb=a=>{for(var b=0,c=0;c<a.length;++c){var d=a.charCodeAt(c);55296<=d&&57343>=d&&++c;b+=4}return b},Mb=0,Nb=(a,b,c)=>{var d=[];a=a.toWireType(d,c);d.length&&(E[b>>>2>>>0]=Q(d));return a},Ob={},Pb=a=>{var b=Ob[a];return void 0===b?J(a):b},Qb=[],Rb=a=>{var b=Qb.length;Qb.push(a);return b},Sb=(a,b)=>{for(var c=Array(a),d=0;d<a;++d)c[d]=zb(E[b+4*d>>>2>>>0],`parameter ${d}`);return c},Tb=Reflect.construct,Y={},\nUb=a=>{if(!(a instanceof va||\"unwind\"==a))throw a;},Vb=a=>{ja=a;Aa||0<Mb||(k.onExit?.(a),y=!0);throw new va(a);},Wb=a=>{if(!y)try{if(a(),!(Aa||0<Mb))try{ja=a=ja,Vb(a)}catch(b){Ub(b)}}catch(b){Ub(b)}},Xb={},Zb=()=>{if(!Yb){var a={USER:\"web_user\",LOGNAME:\"web_user\",PATH:\"/\",PWD:\"/\",HOME:\"/home/web_user\",LANG:(\"object\"==typeof navigator&&navigator.languages&&navigator.languages[0]||\"C\").replace(\"-\",\"_\")+\".UTF-8\",_:da||\"./this.program\"},b;for(b in Xb)void 0===Xb[b]?delete a[b]:a[b]=Xb[b];var c=[];for(b in a)c.push(`${b}=${a[b]}`);\nYb=c}return Yb},Yb,$b=()=>a=>crypto.getRandomValues(a),ac=a=>{(ac=$b())(a)},bc=Array(256),cc=0;256>cc;++cc)bc[cc]=String.fromCharCode(cc);Ea=bc;\n(()=>{let a=Na.prototype;Object.assign(a,{isAliasOf:function(c){if(!(this instanceof Na&&c instanceof Na))return!1;var d=this.V.Y.W,e=this.V.X;c.V=c.V;var f=c.V.Y.W;for(c=c.V.X;d.aa;)e=d.ka(e),d=d.aa;for(;f.aa;)c=f.ka(c),f=f.aa;return d===f&&e===c},clone:function(){this.V.X||Ja(this);if(this.V.ja)return this.V.count.value+=1,this;var c=P,d=Object,e=d.create,f=Object.getPrototypeOf(this),h=this.V;c=c(e.call(d,f,{V:{value:{count:h.count,ia:h.ia,ja:h.ja,X:h.X,Y:h.Y,$:h.$,ba:h.ba}}}));c.V.count.value+=\n1;c.V.ia=!1;return c},[\"delete\"](){this.V.X||Ja(this);if(this.V.ia&&!this.V.ja)throw new M(\"Object already scheduled for deletion\");La(this);var c=this.V;--c.count.value;0===c.count.value&&(c.$?c.ba.fa(c.$):c.Y.W.fa(c.X));this.V.ja||(this.V.$=void 0,this.V.X=void 0)},isDeleted:function(){return!this.V.X},deleteLater:function(){this.V.X||Ja(this);if(this.V.ia&&!this.V.ja)throw new M(\"Object already scheduled for deletion\");Ma.push(this);this.V.ia=!0;return this}});const b=Symbol.dispose;b&&(a[b]=a[\"delete\"])})();\nObject.assign(eb.prototype,{ua(a){this.qa&&(a=this.qa(a));return a},pa(a){this.fa?.(a)},ca:8,readValueFromPointer:Za,fromWireType:function(a){function b(){return this.na?db(this.W.ea,{Y:this.wa,X:c,ba:this,$:a}):db(this.W.ea,{Y:this,X:a})}var c=this.ua(a);if(!c)return this.pa(a),null;var d=bb(this.W,c);if(void 0!==d){if(0===d.V.count.value)return d.V.X=c,d.V.$=a,d.clone();d=d.clone();this.pa(a);return d}d=this.W.ta(c);d=Pa[d];if(!d)return b.call(this);d=this.ma?d.ra:d.pointerType;var e=$a(c,this.W,\nd.W);return null===e?b.call(this):this.na?db(d.W.ea,{Y:d,X:e,ba:this,$:a}):db(d.W.ea,{Y:d,X:e})}});k.noExitRuntime&&(Aa=k.noExitRuntime);k.printErr&&(q=k.printErr);k.wasmBinary&&(u=k.wasmBinary);k.thisProgram&&(da=k.thisProgram);\nvar fc={a:function(a,b,c){a>>>=0;var d=new Ba(a);E[d.X+16>>>2>>>0]=0;E[d.X+4>>>2>>>0]=b>>>0;E[d.X+8>>>2>>>0]=c>>>0;Ca=a;Da++;throw Ca;},M:()=>qa(\"\"),x:function(a,b,c,d,e){a>>>=0;c>>>=0;b=J(b>>>0);d=0n===d;let f=h=>h;if(d){const h=8*c;f=g=>BigInt.asUintN(h,g);e=f(e)}N(a,{name:b,fromWireType:f,toWireType:(h,g)=>{\"number\"==typeof g&&(g=BigInt(g));return g},ca:8,readValueFromPointer:Ha(b,c,!d),da:null})},J:function(a,b,c,d){b=J(b>>>0);N(a>>>0,{name:b,fromWireType:function(e){return!!e},toWireType:function(e,\nf){return f?c:d},ca:8,readValueFromPointer:function(e){return this.fromWireType(z[e>>>0])},da:null})},e:function(a,b,c,d,e,f,h,g,l,n,m,p,r){a>>>=0;b>>>=0;c>>>=0;d>>>=0;f>>>=0;h>>>=0;g>>>=0;l>>>=0;n>>>=0;m>>>=0;p>>>=0;r>>>=0;m=J(m);f=R(e>>>0,f);g&&=R(h,g);n&&=R(l,n);r=R(p,r);var x=Sa(m);Ra(x,function(){T(`Cannot construct ${m} due to unbound types`,[d])});U([a,b,c],d?[d]:[],t=>{t=t[0];if(d){var v=t.W;var F=v.ea}else F=Na.prototype;t=Oa(m,function(...Ia){if(Object.getPrototypeOf(this)!==O)throw new M(`Use 'new' to construct ${m}`);\nif(void 0===C.ha)throw new M(`${m} has no accessible constructor`);var sb=C.ha[Ia.length];if(void 0===sb)throw new M(`Tried to invoke ctor of ${m} with invalid number of parameters (${Ia.length}) - expected (${Object.keys(C.ha).toString()}) parameters instead!`);return sb.apply(this,Ia)});var O=Object.create(F,{constructor:{value:t}});t.prototype=O;var C=new Ta(m,t,O,r,v,f,g,n);if(C.aa){var H;(H=C.aa).la??(H.la=[]);C.aa.la.push(C)}v=new eb(m,C,!0,!1,!1);H=new eb(m+\"*\",C,!1,!1,!1);F=new eb(m+\" const*\",\nC,!1,!0,!1);Pa[a]={pointerType:H,ra:F};fb(x,t);return[v,H,F]})},s:function(a,b,c,d,e,f,h){a>>>=0;b>>>=0;e>>>=0;f>>>=0;h>>>=0;var g=rb(c,d>>>0);b=J(b);b=tb(b);f=R(e,f);U([],[a],l=>{function n(){T(`Cannot call ${m} due to unbound types`,g)}l=l[0];var m=`${l.name}.${b}`;b.startsWith(\"@@\")&&(b=Symbol[b.substring(2)]);var p=l.W.constructor;void 0===p[b]?(n.ga=c-1,p[b]=n):(Qa(p,b,m),p[b].Z[c-1]=n);U([],g,r=>{r=qb(m,[r[0],null].concat(r.slice(1)),null,f,h);void 0===p[b].Z?(r.ga=c-1,p[b]=r):p[b].Z[c-1]=r;\nif(l.W.la)for(const x of l.W.la)x.constructor.hasOwnProperty(b)||(x.constructor[b]=r);return[]});return[]})},y:function(a,b,c,d,e,f,h,g){a>>>=0;b>>>=0;c>>>=0;d>>>=0;f>>>=0;h>>>=0;g>>>=0;b=J(b);f=R(e>>>0,f);U([],[a],l=>{l=l[0];var n=`${l.name}.${b}`,m={get(){T(`Cannot access ${n} due to unbound types`,[c])},enumerable:!0,configurable:!0};m.set=g?()=>{T(`Cannot access ${n} due to unbound types`,[c])}:()=>{throw new M(`${n} is a read-only property`);};Object.defineProperty(l.W.constructor,b,m);U([],\n[c],p=>{p=p[0];var r={get(){return p.fromWireType(f(d))},enumerable:!0};g&&(g=R(h,g),r.set=x=>{var t=[];g(d,p.toWireType(t,x));ob(t)});Object.defineProperty(l.W.constructor,b,r);return[]});return[]})},f:function(a,b,c,d,e,f){a>>>=0;d>>>=0;e>>>=0;f>>>=0;var h=rb(b,c>>>0);e=R(d,e);U([],[a],g=>{g=g[0];var l=`constructor ${g.name}`;void 0===g.W.ha&&(g.W.ha=[]);if(void 0!==g.W.ha[b-1])throw new M(`Cannot register multiple constructors with identical number of parameters (${b-1}) for class '${g.name}'! Overload resolution is currently only performed using the parameter count, not actual type info!`);\ng.W.ha[b-1]=()=>{T(`Cannot construct ${g.name} due to unbound types`,h)};U([],h,n=>{n.splice(1,0,null);g.W.ha[b-1]=qb(l,n,null,e,f);return[]});return[]})},b:function(a,b,c,d,e,f,h,g){a>>>=0;b>>>=0;e>>>=0;f>>>=0;h>>>=0;var l=rb(c,d>>>0);b=J(b);b=tb(b);f=R(e,f);U([],[a],n=>{function m(){T(`Cannot call ${p} due to unbound types`,l)}n=n[0];var p=`${n.name}.${b}`;b.startsWith(\"@@\")&&(b=Symbol[b.substring(2)]);g&&n.W.xa.push(b);var r=n.W.ea,x=r[b];void 0===x||void 0===x.Z&&x.className!==n.name&&x.ga===\nc-2?(m.ga=c-2,m.className=n.name,r[b]=m):(Qa(r,b,p),r[b].Z[c-2]=m);U([],l,t=>{t=qb(p,t,n,f,h);void 0===r[b].Z?(t.ga=c-2,r[b]=t):r[b].Z[c-2]=t;return[]});return[]})},t:function(a,b,c,d,e,f,h,g,l,n){a>>>=0;b>>>=0;c>>>=0;e>>>=0;f>>>=0;h>>>=0;g>>>=0;l>>>=0;n>>>=0;b=J(b);e=R(d>>>0,e);U([],[a],m=>{m=m[0];var p=`${m.name}.${b}`,r={get(){T(`Cannot access ${p} due to unbound types`,[c,h])},enumerable:!0,configurable:!0};r.set=l?()=>T(`Cannot access ${p} due to unbound types`,[c,h]):()=>{throw new M(p+\" is a read-only property\");\n};Object.defineProperty(m.W.ea,b,r);U([],l?[c,h]:[c],x=>{var t=x[0],v={get(){var O=ub(this,m,p+\" getter\");return t.fromWireType(e(f,O))},enumerable:!0};if(l){l=R(g,l);var F=x[1];v.set=function(O){var C=ub(this,m,p+\" setter\"),H=[];l(n,C,F.toWireType(H,O));ob(H)}}Object.defineProperty(m.W.ea,b,v);return[]});return[]})},H:function(a){return N(a>>>0,xb)},v:function(a,b,c,d){function e(){}b=J(b>>>0);e.values={};N(a>>>0,{name:b,constructor:e,fromWireType:function(f){return this.constructor.values[f]},toWireType:(f,\nh)=>h.value,ca:8,readValueFromPointer:yb(b,c>>>0,d),da:null});Ra(b,e)},p:function(a,b,c){b>>>=0;var d=zb(a>>>0,\"enum\");b=J(b);a=d.constructor;d=Object.create(d.constructor.prototype,{value:{value:c},constructor:{value:Oa(`${d.name}_${b}`,function(){})}});a.values[c]=d;a[b]=d},w:function(a,b,c){b=J(b>>>0);N(a>>>0,{name:b,fromWireType:d=>d,toWireType:(d,e)=>e,ca:8,readValueFromPointer:Ab(b,c>>>0),da:null})},o:function(a,b,c,d,e,f){a>>>=0;d>>>=0;e>>>=0;f>>>=0;var h=rb(b,c>>>0);a=J(a);a=tb(a);e=R(d,e);\nRa(a,function(){T(`Cannot call ${a} due to unbound types`,h)},b-1);U([],h,g=>{fb(a,qb(a,[g[0],null].concat(g.slice(1)),null,e,f),b-1);return[]})},r:function(a,b,c,d,e){a>>>=0;c>>>=0;b=J(b>>>0);let f=g=>g;if(0===d){var h=32-8*c;f=g=>g<<h>>>h;e=f(e)}N(a,{name:b,fromWireType:f,toWireType:(g,l)=>l,ca:8,readValueFromPointer:Ha(b,c,0!==d),da:null})},k:function(a,b,c){function d(f){return new e(ka.buffer,E[f+4>>>2>>>0],E[f>>>2>>>0])}var e=[Int8Array,Uint8Array,Int16Array,Uint16Array,Int32Array,Uint32Array,\nFloat32Array,Float64Array,BigInt64Array,BigUint64Array][b];c=J(c>>>0);N(a>>>0,{name:c,fromWireType:d,ca:8,readValueFromPointer:d},{va:!0})},q:function(a){N(a>>>0,Bb)},I:function(a,b){b=J(b>>>0);N(a>>>0,{name:b,fromWireType:function(c){for(var d=E[c>>>2>>>0],e=c+4,f,h=e,g=0;g<=d;++g){var l=e+g;if(g==d||0==z[l>>>0]){var n=h;h=(n>>>=0)?Eb(n,l-h):\"\";void 0===f?f=h:(f+=String.fromCharCode(0),f+=h);h=l+1}}S(c);return f},toWireType:function(c,d){d instanceof ArrayBuffer&&(d=new Uint8Array(d));var e=\"string\"==\ntypeof d;if(!(e||ArrayBuffer.isView(d)&&1==d.BYTES_PER_ELEMENT))throw new M(\"Cannot pass non-string to std::string\");var f=e?Cb(d):d.length;var h=dc(4+f+1),g=h+4;E[h>>>2>>>0]=f;e?X(d,g,f+1):z.set(d,g>>>0);null!==c&&c.push(S,h);return h},ca:8,readValueFromPointer:Za,da(c){S(c)}})},u:function(a,b,c){b>>>=0;c>>>=0;c=J(c);if(2===b){var d=Gb;var e=Hb;var f=Ib;var h=g=>B[g>>>1>>>0]}else 4===b&&(d=Jb,e=Kb,f=Lb,h=g=>E[g>>>2>>>0]);N(a>>>0,{name:c,fromWireType:g=>{for(var l=E[g>>>2>>>0],n,m=g+4,p=0;p<=l;++p){var r=\ng+4+p*b;if(p==l||0==h(r))m=d(m,r-m),void 0===n?n=m:(n+=String.fromCharCode(0),n+=m),m=r+b}S(g);return n},toWireType:(g,l)=>{if(\"string\"!=typeof l)throw new M(`Cannot pass non-string to C++ string type ${c}`);var n=f(l),m=dc(4+n+b);E[m>>>2>>>0]=n/b;e(l,m+4,n+b);null!==g&&g.push(S,m);return m},ca:8,readValueFromPointer:Za,da(g){S(g)}})},K:function(a,b){b=J(b>>>0);N(a>>>0,{Ba:!0,name:b,ca:0,fromWireType:()=>{},toWireType:()=>{}})},D:()=>{Aa=!1;Mb=0},h:function(a,b,c){b>>>=0;c>>>=0;a=W(a>>>0);b=zb(b,\n\"emval::as\");return Nb(b,c,a)},m:function(a,b,c,d,e){c>>>=0;d>>>=0;e>>>=0;a=Qb[a>>>0];b=W(b>>>0);c=Pb(c);return a(b,b[c],d,e)},c:wb,l:function(a,b,c){var d=Sb(a,b>>>0),e=d.shift();a--;var f=Array(a);b=`methodCaller<(${d.map(h=>h.name).join(\", \")}) => ${e.name}>`;return Rb(Oa(b,(h,g,l,n)=>{for(var m=0,p=0;p<a;++p)f[p]=d[p].readValueFromPointer(n+m),m+=d[p].ca;h=1===c?Tb(g,f):g.apply(h,f);return Nb(e,l,h)}))},i:function(a,b){b>>>=0;a=W(a>>>0);b=W(b);return Q(a[b])},n:function(a){a>>>=0;9<a&&(V[a+1]+=\n1)},F:function(){return Q([])},j:function(a){return Q(Pb(a>>>0))},d:function(a){a>>>=0;var b=W(a);ob(b);wb(a)},g:function(a,b){b>>>=0;a=zb(a>>>0,\"_emval_take_value\");a=a.readValueFromPointer(b);return Q(a)},E:(a,b)=>{Y[a]&&(clearTimeout(Y[a].id),delete Y[a]);if(!b)return 0;var c=setTimeout(()=>{delete Y[a];Wb(()=>ec(a,performance.now()))},b);Y[a]={id:c,Ca:b};return 0},A:function(a,b,c,d){c>>>=0;d>>>=0;var e=(new Date).getFullYear(),f=(new Date(e,0,1)).getTimezoneOffset();e=(new Date(e,6,1)).getTimezoneOffset();\nE[a>>>0>>>2>>>0]=60*Math.max(f,e);D[b>>>0>>>2>>>0]=Number(f!=e);b=h=>{var g=Math.abs(h);return`UTC${0<=h?\"-\":\"+\"}${String(Math.floor(g/60)).padStart(2,\"0\")}${String(g%60).padStart(2,\"0\")}`};a=b(f);b=b(e);e<f?(X(a,c,17),X(b,d,17)):(X(a,d,17),X(b,c,17))},L:function(a){a>>>=0;var b=z.length;if(4294901760<a)return!1;for(var c=1;4>=c;c*=2){var d=b*(1+.2/c);d=Math.min(d,a+100663296);a:{d=(Math.min(4294901760,65536*Math.ceil(Math.max(a,d)/65536))-w.buffer.byteLength+65535)/65536|0;try{w.grow(d);pa();var e=\n1;break a}catch(f){}e=void 0}if(e)return!0}return!1},B:function(a,b){a>>>=0;b>>>=0;var c=0,d=0,e;for(e of Zb()){var f=b+c;E[a+d>>>2>>>0]=f;c+=X(e,f,Infinity)+1;d+=4}return 0},G:function(a,b){a>>>=0;b>>>=0;var c=Zb();E[a>>>2>>>0]=c.length;a=0;for(var d of c)a+=Cb(d)+1;E[b>>>2>>>0]=a;return 0},C:Vb,z:function(a,b){a>>>=0;ac(z.subarray(a>>>0,a+(b>>>0)>>>0));return 0}},Z=await (async function(){function a(d){Z=d.exports;Z=gc();w=Z.N;pa();hb=Z.U;G--;k.monitorRunDependencies?.(G);0==G&&I&&(d=\nI,I=null,d());return Z}G++;k.monitorRunDependencies?.(G);var b={a:fc};if(k.instantiateWasm)return new Promise(d=>{k.instantiateWasm(b,(e,f)=>{d(a(e,f))})});ra??=k.locateFile?k.locateFile?k.locateFile(\"seal_allows_wasm_cf_worker.wasm\",fa):fa+\"seal_allows_wasm_cf_worker.wasm\":(new URL(\"seal_allows_wasm_cf_worker.wasm\",import.meta.url)).href;try{var c=await ua(b);return a(c.instance)}catch(d){return ba(d),Promise.reject(d)}}()),hc=k._main=Z.P,mb=Z.Q,ec=Z.R,dc=Z.S,S=Z.T;\nfunction gc(){var a=Z;a=Object.assign({},a);var b=c=>d=>c(d)>>>0;a.Q=b(a.Q);a.S=b(a.S);a._emscripten_stack_alloc=b(a._emscripten_stack_alloc);a.emscripten_stack_get_current=(c=>()=>c()>>>0)(a.emscripten_stack_get_current);return a}\nfunction ic(){function a(){k.calledRun=!0;if(!y){Z.O();aa(k);k.onRuntimeInitialized?.();if(!k.noInitialRun)try{var b=hc(0,0);ja=b;Vb(b)}catch(c){Ub(c)}if(k.postRun)for(\"function\"==typeof k.postRun&&(k.postRun=[k.postRun]);k.postRun.length;)b=k.postRun.shift(),xa.push(b);wa(xa)}}if(0<G)I=ic;else{if(k.preRun)for(\"function\"==typeof k.preRun&&(k.preRun=[k.preRun]);k.preRun.length;)za();wa(ya);0<G?I=ic:k.setStatus?(k.setStatus(\"Running...\"),setTimeout(()=>{setTimeout(()=>k.setStatus(\"\"),1);a()},1)):a()}}\nif(k.preInit)for(\"function\"==typeof k.preInit&&(k.preInit=[k.preInit]);0<k.preInit.length;)k.preInit.shift()();ic();moduleRtn=ca;\n\n\n  return moduleRtn;\n}\n);\n})();\nexport default Module;\n","export const INSTANCE_DELETED = 'Instance was deleted'\nexport const UNSUPPORTED_VECTOR_TYPE = 'Unsupported vector type'\nexport const UNSUPPORTED_BITSIZES_TYPE =\n  'Unsupported argument type! `bitSizes` must be an Int32Array'\nexport const UNSUPPORTED_BATCH_ENCODE_ARRAY_TYPE =\n  'Unsupported array type! `array` must be of type Int32Array, Uint32Array, BigInt64Array, or BigUint64Array.'\nexport const UNSUPPORTED_CKKS_ENCODE_ARRAY_TYPE =\n  'Unsupported array type! `array` must be of type Float64Array.'\nexport const INVALID_PLAIN_CONSRUCTOR_OPTIONS =\n  'Must specify a (coeffCount), (coeffCount, capacity)'\nexport const INVALID_CIPHER_CONSTRUCTOR_OPTIONS =\n  'Must specify a (context), (context, parmsId), or (context, parmsId, sizeCapacity)'\n","import { UNSUPPORTED_BATCH_ENCODE_ARRAY_TYPE } from './constants'\nimport { Context } from './context'\nimport { Exception, SealError } from './exception'\nimport { MemoryPoolHandle } from './memory-pool-handle'\nimport { PlainText, PlainTextConstructorOptions } from './plain-text'\nimport { Instance, Library, LoaderOptions } from './seal'\nimport { VectorConstructorOptions } from './vector'\n\nexport type BatchEncoderDependencyOptions = {\n  readonly Exception: Exception\n  readonly MemoryPoolHandle: MemoryPoolHandle\n  readonly PlainText: PlainTextConstructorOptions\n  readonly Vector: VectorConstructorOptions\n}\n\nexport type BatchEncoderDependencies = {\n  ({\n    Exception,\n    MemoryPoolHandle,\n    PlainText,\n    Vector\n  }: BatchEncoderDependencyOptions): BatchEncoderConstructorOptions\n}\n\nexport type BatchEncoderConstructorOptions = {\n  (context: Context): BatchEncoder\n}\n\nexport type BatchEncoderTypes =\n  | Int32Array\n  | Uint32Array\n  | BigInt64Array\n  | BigUint64Array\n\nexport type BatchEncoder = {\n  readonly instance: Instance\n  readonly unsafeInject: (instance: Instance) => void\n  readonly delete: () => void\n  readonly encode: (\n    array: BatchEncoderTypes,\n    plainText?: PlainText\n  ) => PlainText | void\n  readonly decode: (\n    plainText: PlainText,\n    signed?: boolean,\n    pool?: MemoryPoolHandle\n  ) => Int32Array | Uint32Array\n  readonly decodeBigInt: (\n    plainText: PlainText,\n    signed?: boolean,\n    pool?: MemoryPoolHandle\n  ) => BigInt64Array | BigUint64Array\n  readonly slotCount: number\n}\n\nconst BatchEncoderConstructor =\n  (library: Library): BatchEncoderDependencies =>\n  ({\n    Exception,\n    MemoryPoolHandle,\n    PlainText,\n    Vector\n  }: BatchEncoderDependencyOptions): BatchEncoderConstructorOptions =>\n  (context): BatchEncoder => {\n    const Constructor = library.BatchEncoder\n    let _instance: Instance\n    try {\n      _instance = new Constructor(context.instance)\n    } catch (e) {\n      throw Exception.safe(e as SealError)\n    }\n    /**\n     * @implements BatchEncoder\n     */\n\n    /**\n     * @interface BatchEncoder\n     */\n    return {\n      /**\n       * Get the underlying WASM instance\n       *\n       * @private\n       * @readonly\n       * @name BatchEncoder#instance\n       * @type {Instance}\n       */\n      get instance() {\n        return _instance\n      },\n\n      /**\n       * Inject this object with a raw WASM instance. No type checking is performed.\n       *\n       * @private\n       * @function\n       * @name BatchEncoder#unsafeInject\n       * @param {Instance} instance WASM instance\n       */\n      unsafeInject(instance: Instance) {\n        if (_instance) {\n          _instance.delete()\n          _instance = undefined\n        }\n        _instance = instance\n      },\n\n      /**\n       * Delete the underlying WASM instance.\n       *\n       * Should be called before dereferencing this object to prevent the\n       * WASM heap from growing indefinitely.\n       * @function\n       * @name BatchEncoder#delete\n       */\n      delete() {\n        if (_instance) {\n          _instance.delete()\n          _instance = undefined\n        }\n      },\n\n      /**\n       * Creates a PlainText from a given matrix. This function \"batches\" a given matrix\n       * of either signed or unsigned integers modulo the PlainText modulus into a PlainText element, and stores\n       * the result in the destination parameter. The input array must have size at most equal\n       * to the degree of the polynomial modulus. The first half of the elements represent the\n       * first row of the matrix, and the second half represent the second row. The numbers\n       * in the matrix can be at most equal to the PlainText modulus for it to represent\n       * a valid PlainText.\n       *\n       * If the destination PlainText overlaps the input values in memory, the behavior of\n       * this function is undefined.\n       *\n       * @function\n       * @name BatchEncoder#encode\n       * @param {Int32Array|Uint32Array|BigInt64Array|BigUint64Array} array Data to encode\n       * @param {PlainText} [plainText=null] Destination to store the encoded result\n       * @returns {PlainText|void} A new PlainText holding the encoded data or void if one was provided\n       * @example\n       * import SEAL from 'node-seal'\n       * const seal = await SEAL()\n       * ...\n       * const batchEncoder = seal.BatchEncoder(context)\n       *\n       * const plainText = batchEncoder.encode(Int32Array.from([1, -2, 3]))\n       */\n      encode(\n        array: Int32Array | Uint32Array | BigInt64Array | BigUint64Array,\n        plainText?: PlainText\n      ): PlainText | void {\n        try {\n          if (array.constructor === Int32Array) {\n            if (plainText) {\n              _instance.encode(array, plainText.instance, 'INT32')\n              return\n            }\n            const plain = PlainText()\n            _instance.encode(array, plain.instance, 'INT32')\n            return plain\n          }\n\n          if (array.constructor === Uint32Array) {\n            if (plainText) {\n              _instance.encode(array, plainText.instance, 'UINT32')\n              return\n            }\n            const plain = PlainText()\n            _instance.encode(array, plain.instance, 'UINT32')\n            return plain\n          }\n\n          if (array.constructor === BigInt64Array) {\n            // When embind supports BigInt64Arrays we can remove this hack\n            const stringArray = array.toString().split(',')\n            if (plainText) {\n              _instance.encode(stringArray, plainText.instance, 'INT64')\n              return\n            }\n            const plain = PlainText()\n            _instance.encode(stringArray, plain.instance, 'INT64')\n            return plain\n          }\n\n          if (array.constructor === BigUint64Array) {\n            // When embind supports BigInt64Arrays we can remove this hack\n            const stringArray = array.toString().split(',')\n            if (plainText) {\n              _instance.encode(stringArray, plainText.instance, 'UINT64')\n              return\n            }\n            const plain = PlainText()\n            _instance.encode(stringArray, plain.instance, 'UINT64')\n            return plain\n          }\n\n          throw new Error(UNSUPPORTED_BATCH_ENCODE_ARRAY_TYPE)\n        } catch (e) {\n          throw Exception.safe(e as SealError)\n        }\n      },\n\n      /**\n       * Inverse of encode. This function \"unbatches\" a given PlainText into a matrix\n       * of signed or unsigned integers modulo the PlainText modulus, and stores the result in the destination\n       * parameter. The input PlainText must have degrees less than the polynomial modulus,\n       * and coefficients less than the PlainText modulus, i.e. it must be a valid PlainText\n       * for the encryption parameters. Dynamic memory allocations in the process are\n       * allocated from the memory pool pointed to by the given MemoryPoolHandle.\n       *\n       * @function\n       * @name BatchEncoder#decode\n       * @param {PlainText} plainText Data to decode\n       * @param {boolean} [signed=true] By default, decode as an Int32Array. If false, decode as an Uint32Array\n       * @param {MemoryPoolHandle} [pool={@link MemoryPoolHandle.global}]\n       * @returns {Int32Array|Uint32Array} TypedArray containing the decoded data\n       * @example\n       * import SEAL from 'node-seal'\n       * const seal = await SEAL()\n       * ...\n       * const batchEncoder = seal.BatchEncoder(context)\n       *\n       * const plainText = batchEncoder.encode(Int32Array.from([1, -2, 3]))\n       * const plainTextU = batchEncoder.encode(Uint32Array.from([1, 2, 3]))\n       *\n       * const result = batchEncoder.decode(plainText)\n       * const resultU = batchEncoder.decode(plainTextU, false) // To decode as an Uint32Array\n       */\n      decode(\n        plainText: PlainText,\n        signed = true,\n        pool: MemoryPoolHandle = MemoryPoolHandle.global\n      ): Int32Array | Uint32Array {\n        try {\n          if (signed) {\n            const tempVect = Vector()\n            const instance = _instance.decodeInt32(plainText.instance, pool)\n            tempVect.unsafeInject(instance)\n            tempVect.setType('Int32Array')\n            const tempArr = tempVect.toArray() as Int32Array\n            tempVect.delete()\n            return tempArr\n          }\n          const tempVect = Vector()\n          const instance = _instance.decodeUint32(plainText.instance, pool)\n          tempVect.unsafeInject(instance)\n          tempVect.setType('Uint32Array')\n          const tempArr = tempVect.toArray() as Uint32Array\n          tempVect.delete()\n          return tempArr\n        } catch (e) {\n          throw Exception.safe(e as SealError)\n        }\n      },\n\n      /**\n       * Performs the same function as the 32-bit decode, but supports true\n       * 64-bit values encapsulated by a BigInt.\n       *\n       * There's no official support for sending a BigInt64Array/BigUint64Array\n       * from C++ to JS, therefore this function uses string conversion to\n       * marshal data which is noticably slower. Use this function if you\n       * absolutely need to marshal values larger than 32 bits.\n       *\n       * @see {@link BatchEncoder#decode} for more information about decode.\n       * @function\n       * @name BatchEncoder#decodeBigInt\n       * @param {PlainText} plainText Data to decode\n       * @param {boolean} [signed=true] By default, decode as an BigInt64Array. If false, decode as an BigUint64Array\n       * @param {MemoryPoolHandle} [pool={@link MemoryPoolHandle.global}]\n       * @returns {BigInt64Array|BigUint64Array} TypedArray containing the decoded data\n       * @example\n       * import SEAL from 'node-seal'\n       * const seal = await SEAL()\n       * ...\n       * const batchEncoder = seal.BatchEncoder(context)\n       *\n       * const plainText = batchEncoder.encode(BigInt64Array.from([1n, -2n, 3n]))\n       * const plainTextU = batchEncoder.encode(BigUint64Array.from([1n, 2n, 3n]))\n       *\n       * const result = batchEncoder.decodeBigInt(plainText)\n       * const resultU = batchEncoder.decodeBigInt(plainTextU, false) // To decode as an BigUint64Array\n       */\n      decodeBigInt(\n        plainText: PlainText,\n        signed = true,\n        pool: MemoryPoolHandle = MemoryPoolHandle.global\n      ): BigInt64Array | BigUint64Array {\n        try {\n          if (signed) {\n            const instance = _instance.decodeBigInt(\n              plainText.instance,\n              true,\n              pool\n            )\n            return BigInt64Array.from(instance)\n          }\n          const instance = _instance.decodeBigInt(\n            plainText.instance,\n            false,\n            pool\n          )\n          return BigUint64Array.from(instance)\n        } catch (e) {\n          throw Exception.safe(e as SealError)\n        }\n      },\n\n      /**\n       * The total number of batching slots available to hold data\n       *\n       * @readonly\n       * @name BatchEncoder#slotCount\n       * @type {number}\n       */\n      get slotCount() {\n        return _instance.slotCount()\n      }\n    }\n  }\n\nexport const BatchEncoderInit = ({\n  loader\n}: LoaderOptions): BatchEncoderDependencies => {\n  const library: Library = loader.library\n  return BatchEncoderConstructor(library)\n}\n","import { ComprModeType } from './compr-mode-type'\nimport { INVALID_CIPHER_CONSTRUCTOR_OPTIONS } from './constants'\nimport { Context } from './context'\nimport { Exception, SealError } from './exception'\nimport { MemoryPoolHandle } from './memory-pool-handle'\nimport { ParmsIdType, ParmsIdTypeConstructorOptions } from './parms-id-type'\nimport { Instance, Library, LoaderOptions } from './seal'\nimport { VectorConstructorOptions } from './vector'\nexport type CipherTextDependencyOptions = {\n  readonly Exception: Exception\n  readonly ComprModeType: ComprModeType\n  readonly ParmsIdType: ParmsIdTypeConstructorOptions\n  readonly MemoryPoolHandle: MemoryPoolHandle\n  readonly Vector: VectorConstructorOptions\n}\n\nexport type CipherTextDependencies = {\n  ({\n    Exception,\n    ComprModeType,\n    ParmsIdType,\n    MemoryPoolHandle,\n    Vector\n  }: CipherTextDependencyOptions): CipherTextConstructorOptions\n}\n\nexport type CipherTextConstructorOptions = {\n  ({\n    context,\n    parmsId,\n    sizeCapacity,\n    pool\n  }?: {\n    context?: Context\n    parmsId?: ParmsIdType\n    sizeCapacity?: number\n    pool?: MemoryPoolHandle\n  }): CipherText\n}\n\nexport type CipherText = {\n  readonly instance: Instance\n  readonly unsafeInject: (instance: Instance) => void\n  readonly delete: () => void\n  readonly reserve: (context: Context, capacity: number) => void\n  readonly resize: (size: number) => void\n  readonly release: () => void\n  readonly coeffModulusSize: number\n  readonly polyModulusDegree: number\n  readonly size: number\n  readonly sizeCapacity: number\n  readonly isTransparent: boolean\n  readonly isNttForm: boolean\n  readonly parmsId: ParmsIdType\n  readonly scale: number\n  readonly setScale: (scale: number) => void\n  readonly pool: MemoryPoolHandle\n  readonly save: (compression?: ComprModeType) => string\n  readonly saveArray: (compression?: ComprModeType) => Uint8Array\n  readonly load: (context: Context, encoded: string) => void\n  readonly loadArray: (context: Context, array: Uint8Array) => void\n  readonly copy: (cipher: CipherText) => void\n  readonly clone: () => CipherText\n  readonly move: (cipher: CipherText) => void\n}\n\nconst CipherTextConstructor =\n  (library: Library): CipherTextDependencies =>\n  ({\n    Exception,\n    ComprModeType,\n    ParmsIdType,\n    MemoryPoolHandle,\n    Vector\n  }: CipherTextDependencyOptions): CipherTextConstructorOptions =>\n  ({\n    context,\n    parmsId,\n    sizeCapacity,\n    pool = MemoryPoolHandle.global\n  } = {}): CipherText => {\n    // Static methods\n    const Constructor = library.Ciphertext\n\n    let _instance = construct({\n      context,\n      parmsId,\n      sizeCapacity,\n      pool\n    })\n\n    function construct({\n      context,\n      parmsId,\n      sizeCapacity,\n      pool = MemoryPoolHandle.global\n    }: {\n      context?: Context\n      parmsId?: ParmsIdType\n      sizeCapacity?: number\n      pool?: MemoryPoolHandle\n    } = {}) {\n      try {\n        if (!context && !parmsId && sizeCapacity === undefined) {\n          return new Constructor(pool)\n        } else if (context && !parmsId && sizeCapacity === undefined) {\n          return new Constructor(context.instance, pool)\n        } else if (context && parmsId && sizeCapacity === undefined) {\n          return new Constructor(context.instance, parmsId.instance, pool)\n        } else if (context && parmsId && sizeCapacity !== undefined) {\n          return new Constructor(\n            context.instance,\n            parmsId.instance,\n            sizeCapacity,\n            pool\n          )\n        } else {\n          throw new Error(INVALID_CIPHER_CONSTRUCTOR_OPTIONS)\n        }\n      } catch (e) {\n        throw Exception.safe(e as SealError)\n      }\n    }\n    /**\n     * @implements CipherText\n     */\n\n    /**\n     * @interface CipherText\n     */\n    return {\n      /**\n       * Get the underlying WASM instance\n       *\n       * @private\n       * @readonly\n       * @name CipherText#instance\n       * @type {Instance}\n       */\n      get instance() {\n        return _instance\n      },\n\n      /**\n       * Inject this object with a raw WASM instance. No type checking is performed.\n       *\n       * @private\n       * @function\n       * @name CipherText#unsafeInject\n       * @param {Instance} instance WASM instance\n       */\n      unsafeInject(instance: Instance) {\n        if (_instance) {\n          _instance.delete()\n          _instance = undefined\n        }\n        _instance = instance\n      },\n\n      /**\n       * Delete the underlying WASM instance.\n       *\n       * Should be called before dereferencing this object to prevent the\n       * WASM heap from growing indefinitely.\n       * @function\n       * @name CipherText#delete\n       */\n      delete() {\n        if (_instance) {\n          _instance.delete()\n          _instance = undefined\n        }\n      },\n\n      /**\n       * Allocates enough memory to accommodate the backing array of a ciphertext\n       * with given capacity. In addition to the capacity, the allocation size is\n       * determined by the current encryption parameters.\n       *\n       * @function\n       * @name CipherText#reserve\n       * @param {Context} context The SEAL Context\n       * @param {number} capacity The capacity to reserve\n       */\n      reserve(context: Context, capacity: number) {\n        try {\n          return _instance.reserve(context.instance, capacity)\n        } catch (e) {\n          throw Exception.safe(e as SealError)\n        }\n      },\n\n      /**\n       * Resizes the CipherText to given size, reallocating if the capacity\n       * of the CipherText is too small.\n       *\n       * This function is mainly intended for internal use and is called\n       * automatically by functions such as Evaluator.multiply and\n       * Evaluator.relinearize. A normal user should never have a reason\n       * to manually resize a CipherText.\n       *\n       * @function\n       * @name CipherText#resize\n       * @param {number} size The new size\n       */\n      resize(size: number) {\n        try {\n          return _instance.resize(size)\n        } catch (e) {\n          throw Exception.safe(e as SealError)\n        }\n      },\n\n      /**\n       * Resets the CipherText. This function releases any memory allocated\n       * by the CipherText, returning it to the memory pool. It also sets all\n       * encryption parameter specific size information to zero.\n       *\n       * @function\n       * @name CipherText#release\n       */\n      release() {\n        _instance.release()\n      },\n\n      /**\n       * The number of primes in the coefficient modulus of the\n       * associated encryption parameters. This directly affects the\n       * allocation size of the CipherText.\n       *\n       * @readonly\n       * @name CipherText#coeffModulusSize\n       * @type {number}\n       */\n      get coeffModulusSize() {\n        return _instance.coeffModulusSize()\n      },\n\n      /**\n       * The degree of the polynomial modulus of the associated\n       * encryption parameters. This directly affects the allocation size\n       * of the CipherText.\n       *\n       * @readonly\n       * @name CipherText#polyModulusDegree\n       * @type {number}\n       */\n      get polyModulusDegree() {\n        return _instance.polyModulusDegree()\n      },\n\n      /**\n       * The size of the CipherText.\n       *\n       * @readonly\n       * @name CipherText#size\n       * @type {number}\n       */\n      get size() {\n        return _instance.size()\n      },\n\n      /**\n       * The capacity of the allocation. This means the largest size\n       * of the CipherText that can be stored in the current allocation with\n       * the current encryption parameters.\n       *\n       * @readonly\n       * @name CipherText#sizeCapacity\n       * @type {number}\n       */\n      get sizeCapacity() {\n        return _instance.sizeCapacity()\n      },\n\n      /**\n       * Whether the current CipherText is transparent, i.e. does not require\n       * a secret key to decrypt. In typical security models such transparent\n       * CipherTexts would not be considered to be valid. Starting from the second\n       * polynomial in the current CipherText, this function returns true if all\n       * following coefficients are identically zero. Otherwise, returns false.\n       *\n       * @readonly\n       * @name CipherText#isTransparent\n       * @type {boolean}\n       */\n      get isTransparent() {\n        return _instance.isTransparent()\n      },\n\n      /**\n       * Whether the CipherText is in NTT form.\n       *\n       * @readonly\n       * @name CipherText#isNttForm\n       * @type {boolean}\n       */\n      get isNttForm() {\n        return _instance.isNttForm()\n      },\n\n      /**\n       * The reference to parmsId.\n       * @see {@link EncryptionParameters} for more information about parmsId.\n       *\n       * @readonly\n       * @name CipherText#parmsId\n       * @type {ParmsIdType}\n       */\n      get parmsId() {\n        const parms = ParmsIdType()\n        parms.inject(_instance.parmsId())\n        return parms\n      },\n\n      /**\n       * The reference to the scale. This is only needed when using the\n       * CKKS encryption scheme. The user should have little or no reason to ever\n       * change the scale by hand.\n       *\n       * @readonly\n       * @name CipherText#scale\n       * @type {number}\n       */\n      get scale() {\n        return _instance.scale()\n      },\n\n      /**\n       * Sets the CipherText scale. This is only needed when using the\n       * CKKS encryption scheme. The user should have little or no reason to ever\n       * change the scale by hand.\n       *\n       * @function\n       * @name CipherText#setScale\n       * @param {number} scale The scale to set\n       */\n      setScale(scale: number) {\n        _instance.setScale(scale)\n      },\n\n      /**\n       * The currently used MemoryPoolHandle.\n       *\n       * @readonly\n       * @name CipherText#pool\n       * @type {MemoryPoolHandle}\n       */\n      get pool() {\n        return _instance.pool()\n      },\n\n      /**\n       * Save the CipherText to a base64 string\n       *\n       * @function\n       * @name CipherText#save\n       * @param {ComprModeType} [compression={@link ComprModeType.zstd}] The compression mode to use\n       * @returns {string} Base64 encoded string\n       */\n      save(compression: ComprModeType = ComprModeType.zstd): string {\n        return _instance.saveToString(compression)\n      },\n\n      /**\n       * Save the CipherText as a binary Uint8Array\n       *\n       * @function\n       * @name CipherText#saveArray\n       * @param {ComprModeType} [compression={@link ComprModeType.zstd}] The compression mode to use\n       * @returns {Uint8Array} A byte array containing the CipherText in binary form\n       */\n      saveArray(compression: ComprModeType = ComprModeType.zstd): Uint8Array {\n        const tempVect = Vector()\n        const instance = _instance.saveToArray(compression)\n        tempVect.unsafeInject(instance)\n        tempVect.setType('Uint8Array')\n        const tempArr = tempVect.toArray() as Uint8Array\n        tempVect.delete()\n        return tempArr\n      },\n\n      /**\n       * Load a CipherText from a base64 string\n       *\n       * @function\n       * @name CipherText#load\n       * @param {Context} context Encryption context to enforce\n       * @param {string} encoded Base64 encoded string\n       */\n      load(context: Context, encoded: string) {\n        try {\n          _instance.loadFromString(context.instance, encoded)\n        } catch (e) {\n          throw Exception.safe(e as SealError)\n        }\n      },\n\n      /**\n       * Load a CipherText from an Uint8Array holding binary data\n       *\n       * @function\n       * @name CipherText#loadArray\n       * @param {Context} context Encryption context to enforce\n       * @param {Uint8Array} array TypedArray containing binary data\n       */\n      loadArray(context: Context, array: Uint8Array) {\n        try {\n          _instance.loadFromArray(context.instance, array)\n        } catch (e) {\n          throw Exception.safe(e as SealError)\n        }\n      },\n\n      /**\n       * Copy an existing CipherText and overwrite this instance\n       *\n       * @function\n       * @name CipherText#copy\n       * @param {CipherText} cipher CipherText to copy\n       * @example\n       * const cipherTextA = seal.CipherText()\n       * // ... after encoding some data ...\n       * const cipherTextB = seal.CipherText()\n       * cipherTextB.copy(cipherTextA)\n       * // cipherTextB holds a copy of cipherTextA\n       */\n      copy(cipher: CipherText) {\n        try {\n          _instance.copy(cipher.instance)\n        } catch (e) {\n          throw Exception.safe(e as SealError)\n        }\n      },\n\n      /**\n       * Clone and return a new instance of this CipherText\n       *\n       * @function\n       * @name CipherText#clone\n       * @returns {CipherText}\n       * @example\n       * const cipherTextA = seal.CipherText()\n       * // ... after encoding some data ...\n       * const cipherTextB = cipherTextA.clone()\n       * // cipherTextB holds a copy of cipherTextA\n       */\n      clone(): CipherText {\n        try {\n          const clonedInstance = _instance.clone()\n          const cipher = CipherTextConstructor(library)({\n            Exception,\n            ComprModeType,\n            ParmsIdType,\n            MemoryPoolHandle,\n            Vector\n          })()\n          cipher.unsafeInject(clonedInstance)\n          return cipher\n        } catch (e) {\n          throw Exception.safe(e as SealError)\n        }\n      },\n\n      /**\n       * Move a CipherText into this one and delete the old reference\n       *\n       * @function\n       * @name CipherText#move\n       * @param {CipherText} cipher CipherText to move\n       * @example\n       * const cipherTextA = seal.CipherText()\n       * // ... after encoding some data ...\n       * const cipherTextB = seal.CipherText()\n       * cipherTextB.move(cipherTextA)\n       * // cipherTextB holds a the instance of cipherTextA.\n       * // cipherTextA no longer holds an instance\n       */\n      move(cipher: CipherText) {\n        try {\n          _instance.move(cipher.instance)\n          // TODO: find optimization\n          // This method results in a copy instead of a real move.\n          // Therefore, we need to delete the old instance.\n          cipher.delete()\n        } catch (e) {\n          throw Exception.safe(e as SealError)\n        }\n      }\n    }\n  }\n\nexport const CipherTextInit = ({\n  loader\n}: LoaderOptions): CipherTextDependencies => {\n  const library: Library = loader.library\n  return CipherTextConstructor(library)\n}\n","import { UNSUPPORTED_CKKS_ENCODE_ARRAY_TYPE } from './constants'\nimport { Context } from './context'\nimport { Exception, SealError } from './exception'\nimport { MemoryPoolHandle } from './memory-pool-handle'\nimport { PlainText, PlainTextConstructorOptions } from './plain-text'\nimport { Instance, Library, LoaderOptions } from './seal'\nimport { VectorConstructorOptions } from './vector'\n\nexport type CKKSEncoderDependencyOptions = {\n  readonly Exception: Exception\n  readonly MemoryPoolHandle: MemoryPoolHandle\n  readonly PlainText: PlainTextConstructorOptions\n  readonly Vector: VectorConstructorOptions\n}\n\nexport type CKKSEncoderDependencies = {\n  ({\n    Exception,\n    MemoryPoolHandle,\n    PlainText,\n    Vector\n  }: CKKSEncoderDependencyOptions): CKKSEncoderConstructorOptions\n}\n\nexport type CKKSEncoderConstructorOptions = {\n  (context: Context): CKKSEncoder\n}\n\nexport type CKKSEncoderTypes = Float64Array\n\nexport type CKKSEncoder = {\n  readonly instance: Instance\n  readonly unsafeInject: (instance: Instance) => void\n  readonly delete: () => void\n  readonly encode: (\n    array: CKKSEncoderTypes,\n    scale: number,\n    plainText?: PlainText,\n    pool?: MemoryPoolHandle\n  ) => PlainText | void\n  readonly decode: (\n    plainText: PlainText,\n    pool?: MemoryPoolHandle\n  ) => CKKSEncoderTypes\n  readonly slotCount: number\n}\n\nconst CKKSEncoderConstructor =\n  (library: Library): CKKSEncoderDependencies =>\n  ({\n    Exception,\n    MemoryPoolHandle,\n    PlainText,\n    Vector\n  }: CKKSEncoderDependencyOptions): CKKSEncoderConstructorOptions =>\n  (context): CKKSEncoder => {\n    const Constructor = library.CKKSEncoder\n    let _instance: Instance\n    try {\n      _instance = new Constructor(context.instance)\n    } catch (e) {\n      throw Exception.safe(e as SealError)\n    }\n    /**\n     * @implements CKKSEncoder\n     */\n\n    /**\n     * @interface CKKSEncoder\n     */\n    return {\n      /**\n       * Get the underlying WASM instance\n       *\n       * @private\n       * @readonly\n       * @name CKKSEncoder#instance\n       * @type {Instance}\n       */\n      get instance() {\n        return _instance\n      },\n\n      /**\n       * Inject this object with a raw WASM instance. No type checking is performed.\n       *\n       * @private\n       * @function\n       * @name CKKSEncoder#unsafeInject\n       * @param {Instance} instance WASM instance\n       */\n      unsafeInject(instance: Instance) {\n        if (_instance) {\n          _instance.delete()\n          _instance = undefined\n        }\n        _instance = instance\n      },\n\n      /**\n       * Delete the underlying WASM instance.\n       *\n       * Should be called before dereferencing this object to prevent the\n       * WASM heap from growing indefinitely.\n       * @function\n       * @name CKKSEncoder#delete\n       */\n      delete() {\n        if (_instance) {\n          _instance.delete()\n          _instance = undefined\n        }\n      },\n\n      /**\n       * Encodes a vector of double-precision floating-point real numbers\n       * into a plaintext polynomial. Append zeros if vector size is less than N/2.\n       * Dynamic memory allocations in the process are allocated from the memory\n       * pool pointed to by the given MemoryPoolHandle.\n       *\n       * @function\n       * @name CKKSEncoder#encode\n       * @param {Float64Array} array Data to encode\n       * @param {number} scale Scaling parameter defining encoding precision\n       * @param {PlainText} [plainText] Destination to store the encoded result\n       * @param {MemoryPoolHandle} [pool={@link MemoryPoolHandle.global}] MemoryPool to use\n       * @returns {PlainText|void} A new PlainText holding the encoded data or void if one was provided\n       * @example\n       * import SEAL from 'node-seal'\n       * const seal = await SEAL()\n       * ...\n       * const ckksEncoder = seal.CKKSEncoder(context)\n       *\n       * const plainText = ckksEncoder.encode(Float64Array.from([1.11, -2.222, 3.333]), Math.pow(2, 20))\n       */\n      encode(\n        array: Float64Array,\n        scale: number,\n        plainText?: PlainText,\n        pool: MemoryPoolHandle = MemoryPoolHandle.global\n      ): PlainText | void {\n        try {\n          if (array.constructor === Float64Array) {\n            if (plainText) {\n              _instance.encode(array, scale, plainText.instance, pool)\n              return\n            }\n            const plain = PlainText()\n            _instance.encode(array, scale, plain.instance, pool)\n            return plain\n          } else {\n            throw new Error(UNSUPPORTED_CKKS_ENCODE_ARRAY_TYPE)\n          }\n        } catch (e) {\n          throw Exception.safe(e as SealError)\n        }\n      },\n\n      /**\n       * Decodes a plaintext polynomial into double-precision floating-point\n       * real numbers. Dynamic memory allocations in the process are\n       * allocated from the memory pool pointed to by the given MemoryPoolHandle.\n       *\n       * @function\n       * @name CKKSEncoder#decode\n       * @param {PlainText} plainText Data to decode\n       * @param {MemoryPoolHandle} [pool={@link MemoryPoolHandle.global}] MemoryPool to use\n       * @returns {Float64Array} TypedArray containing the decoded data\n       * @example\n       * import SEAL from 'node-seal'\n       * const seal = await SEAL()\n       * ...\n       * const ckksEncoder = seal.CKKSEncoder(context)\n       *\n       * const plainText = ckksEncoder.encode(Float64Array.from([1, 2, 3]))\n       *\n       * const result = ckksEncoder.decode(plainText)\n       */\n      decode(\n        plainText: PlainText,\n        pool: MemoryPoolHandle = MemoryPoolHandle.global\n      ): Float64Array {\n        try {\n          const tempVect = Vector()\n          const instance = _instance.decodeDouble(plainText.instance, pool)\n          tempVect.unsafeInject(instance)\n          tempVect.setType('Float64Array')\n          const tempArr = tempVect.toArray() as Float64Array\n          tempVect.delete()\n          return tempArr\n        } catch (e) {\n          throw Exception.safe(e as SealError)\n        }\n      },\n\n      /**\n       * The total number of CKKS slots available to hold data\n       *\n       * @readonly\n       * @name CKKSEncoder#slotCount\n       * @type {number}\n       */\n      get slotCount() {\n        return _instance.slotCount()\n      }\n    }\n  }\n\nexport const CKKSEncoderInit = ({\n  loader\n}: LoaderOptions): CKKSEncoderDependencies => {\n  const library: Library = loader.library\n  return CKKSEncoderConstructor(library)\n}\n","import { UNSUPPORTED_BITSIZES_TYPE } from './constants'\nimport { Exception, SealError } from './exception'\nimport { Library, LoaderOptions } from './seal'\nimport { SecurityLevel } from './security-level'\nimport { Vector, VectorConstructorOptions } from './vector'\n\nexport type CoeffModulusDependencyOptions = {\n  readonly Exception: Exception\n  readonly SecurityLevel: SecurityLevel\n  readonly Vector: VectorConstructorOptions\n}\n\nexport type CoeffModulusDependencies = {\n  ({\n    Exception,\n    SecurityLevel,\n    Vector\n  }: CoeffModulusDependencyOptions): CoeffModulusConstructorOptions\n}\n\nexport type CoeffModulusConstructorOptions = {\n  (): CoeffModulus\n}\n\nexport type CoeffModulus = {\n  readonly MaxBitCount: (\n    polyModulusDegree: number,\n    securityLevel?: SecurityLevel\n  ) => number\n  readonly BFVDefault: (\n    polyModulusDegree: number,\n    securityLevel?: SecurityLevel\n  ) => Vector\n  readonly Create: (polyModulusDegree: number, bitSizes: Int32Array) => Vector\n}\n\nconst CoeffModulusConstructor =\n  (library: Library): CoeffModulusDependencies =>\n  ({\n    Exception,\n    SecurityLevel,\n    Vector\n  }: CoeffModulusDependencyOptions): CoeffModulusConstructorOptions =>\n  (): CoeffModulus => {\n    // Static methods\n    const _MaxBitCount = library.CoeffModulus.MaxBitCount\n    const _BFVDefault = library.CoeffModulus.BFVDefault\n    const _CreateFromArray = library.CoeffModulus.CreateFromArray\n\n    /**\n     * @implements CoeffModulus\n     */\n\n    /**\n     * @interface CoeffModulus\n     */\n    return {\n      /**\n       * Returns the Maximum Bit Count for the specified polyModulusDegree and securityLevel\n       *\n       * @function\n       * @name CoeffModulus.MaxBitCount\n       * @param {number} polyModulusDegree Degree of the polynomial modulus\n       * @param {SecurityLevel} [securityLevel={@link SecurityLevel.tc128}] Security Level\n       * @returns {number} Maximum bit count\n       */\n      MaxBitCount(\n        polyModulusDegree: number,\n        securityLevel: SecurityLevel = SecurityLevel.tc128\n      ): number {\n        return _MaxBitCount(polyModulusDegree, securityLevel)\n      },\n\n      /**\n       * Returns a default vector of primes for the BFV CoeffModulus parameter\n       *\n       * @function\n       * @name CoeffModulus.BFVDefault\n       * @param {number} polyModulusDegree Degree of the polynomial modulus\n       * @param {SecurityLevel} [securityLevel={@link SecurityLevel.tc128}] Security Level\n       * @returns {Vector} Vector containing Modulus primes\n       */\n      BFVDefault(\n        polyModulusDegree: number,\n        securityLevel: SecurityLevel = SecurityLevel.tc128\n      ): Vector {\n        try {\n          const vectorModulus = Vector()\n          const instance = _BFVDefault(polyModulusDegree, securityLevel)\n          vectorModulus.unsafeInject(instance)\n          vectorModulus.setType('Modulus')\n          return vectorModulus\n        } catch (e) {\n          throw Exception.safe(e as SealError)\n        }\n      },\n\n      /**\n       * Creates a vector of primes for a given polyModulusDegree and bitSizes\n       *\n       * @function\n       * @name CoeffModulus.Create\n       * @param {number} polyModulusDegree Degree of the polynomial modulus\n       * @param {Int32Array} bitSizes Int32Array containing values representing\n       * bit-sizes of primes\n       * @returns {Vector} Vector containing Modulus primes\n       */\n      Create(polyModulusDegree: number, bitSizes: Int32Array): Vector {\n        try {\n          if (bitSizes.constructor !== Int32Array) {\n            throw new Error(UNSUPPORTED_BITSIZES_TYPE)\n          }\n          const vectorModulus = Vector()\n          const instance = _CreateFromArray(polyModulusDegree, bitSizes)\n          vectorModulus.unsafeInject(instance)\n          vectorModulus.setType('Modulus')\n          return vectorModulus\n        } catch (e) {\n          throw Exception.safe(e as SealError)\n        }\n      }\n    }\n  }\n\nexport const CoeffModulusInit = ({\n  loader\n}: LoaderOptions): CoeffModulusDependencies => {\n  const library: Library = loader.library\n  return CoeffModulusConstructor(library)\n}\n","import { Library, LoaderOptions } from './seal'\n\nexport type ComprModeTypeDependencies = {\n  (): ComprModeTypeConstructorOptions\n}\n\nexport type ComprModeTypeConstructorOptions = {\n  (): ComprModeType\n}\n\nexport type ComprModeType = {\n  readonly none: any\n  readonly zlib: any\n  readonly zstd: any\n}\n\nconst ComprModeTypeConstructor =\n  (library: Library): ComprModeTypeDependencies =>\n  (): ComprModeTypeConstructorOptions =>\n  (): ComprModeType => {\n    // Static methods\n    const _none = library.ComprModeType.none\n    const _zlib = library.ComprModeType.zlib\n    const _zstd = library.ComprModeType.zstd\n\n    /**\n     * @implements ComprModeType\n     */\n\n    /**\n     * @interface ComprModeType\n     */\n    return {\n      /**\n       * The `none` Compression Mode Type\n       *\n       * @readonly\n       * @name ComprModeType.none\n       * @type {ComprModeType.none}\n       */\n      get none() {\n        /**\n         * @typedef {ComprModeType.none} ComprModeType.none\n         */\n        return _none\n      },\n\n      /**\n       * The `zlib` Compression Mode Type\n       *\n       * @readonly\n       * @name ComprModeType.zlib\n       * @type {ComprModeType.zlib}\n       */\n      get zlib() {\n        /**\n         * @typedef {ComprModeType.zlib} ComprModeType.zlib\n         */\n        return _zlib\n      },\n\n      /**\n       * The `zstd` Compression Mode Type\n       *\n       * @readonly\n       * @name ComprModeType.zstd\n       * @type {ComprModeType.zstd}\n       */\n      get zstd() {\n        /**\n         * @typedef {ComprModeType.zstd} ComprModeType.zstd\n         */\n        return _zstd\n      }\n    }\n  }\n\nexport const ComprModeTypeInit = ({\n  loader\n}: LoaderOptions): ComprModeTypeDependencies => {\n  const library: Library = loader.library\n  return ComprModeTypeConstructor(library)\n}\n","import { ContextData, ContextDataConstructorOptions } from './context-data'\nimport { EncryptionParameters } from './encryption-parameters'\nimport { ParmsIdType, ParmsIdTypeConstructorOptions } from './parms-id-type'\nimport { Instance, Library, LoaderOptions } from './seal'\nimport { SecurityLevel } from './security-level'\n\nexport type ContextDependencyOptions = {\n  readonly ParmsIdType: ParmsIdTypeConstructorOptions\n  readonly ContextData: ContextDataConstructorOptions\n  readonly SecurityLevel: SecurityLevel\n}\n\nexport type ContextDependencies = {\n  ({\n    ParmsIdType,\n    ContextData,\n    SecurityLevel\n  }: ContextDependencyOptions): ContextConstructorOptions\n}\n\nexport type ContextConstructorOptions = {\n  (\n    encryptionParams: EncryptionParameters,\n    expandModChain?: boolean,\n    securityLevel?: SecurityLevel\n  ): Context\n}\n\nexport type Context = {\n  readonly instance: Instance\n  readonly unsafeInject: (instance: Instance) => void\n  readonly delete: () => void\n  readonly toHuman: () => string\n  readonly getContextData: (parmsId: ParmsIdType) => ContextData\n  readonly keyContextData: ContextData\n  readonly firstContextData: ContextData\n  readonly lastContextData: ContextData\n  readonly parametersSet: () => boolean\n  readonly keyParmsId: ParmsIdType\n  readonly firstParmsId: ParmsIdType\n  readonly lastParmsId: ParmsIdType\n  readonly usingKeyswitching: boolean\n}\n\nconst ContextConstructor =\n  (library: Library): ContextDependencies =>\n  ({\n    ParmsIdType,\n    ContextData,\n    SecurityLevel\n  }: ContextDependencyOptions): ContextConstructorOptions =>\n  (\n    encryptionParams,\n    expandModChain = true,\n    securityLevel = SecurityLevel.tc128\n  ): Context => {\n    // Static methods\n    const Constructor = library.SEALContext\n\n    let _instance = new Constructor(\n      encryptionParams.instance,\n      expandModChain,\n      securityLevel\n    ) as Instance\n\n    /**\n     * @implements Context\n     */\n\n    /**\n     * @interface Context\n     */\n    return {\n      /**\n       * Get the underlying WASM instance\n       *\n       * @private\n       * @readonly\n       * @name Context#instance\n       * @type {Instance}\n       */\n      get instance() {\n        return _instance\n      },\n\n      /**\n       * Inject this object with a raw WASM instance. No type checking is performed.\n       *\n       * @private\n       * @function\n       * @name Context#unsafeInject\n       * @param {Instance} instance WASM instance\n       */\n      unsafeInject(instance: Instance) {\n        if (_instance) {\n          _instance.delete()\n          _instance = undefined\n        }\n        _instance = instance\n      },\n\n      /**\n       * Delete the underlying WASM instance.\n       *\n       * Should be called before dereferencing this object to prevent the\n       * WASM heap from growing indefinitely.\n       * @function\n       * @name Context#delete\n       */\n      delete() {\n        if (_instance) {\n          _instance.delete()\n          _instance = undefined\n        }\n      },\n\n      /**\n       * Returns the context parameters in a human readable string format.\n       *\n       * @private\n       * @function\n       * @name Context#toString\n       * @returns {string} Context details as a string\n       */\n      toHuman(): string {\n        return _instance.toHuman()\n      },\n\n      /**\n       * Returns the ContextData corresponding to encryption parameters with a given\n       * parmsId. If parameters with the given parmsId are not found then the\n       * function returns nullptr.\n       *\n       * @function\n       * @name Context#getContextData\n       * @param {ParmsIdType} parmsId Specific id to return ContextData for\n       * @returns {ContextData} ContextData corresponding to encryption parameters\n       */\n      getContextData(parmsId: ParmsIdType): ContextData {\n        const instance = _instance.getContextData(parmsId.instance)\n        const contextData = ContextData()\n        contextData.unsafeInject(instance)\n        return contextData\n      },\n\n      /**\n       * The ContextData corresponding to encryption parameters that are used for keys.\n       *\n       * @readonly\n       * @name Context#keyContextData\n       * @type {ContextData}\n       */\n      get keyContextData() {\n        const instance = _instance.keyContextData()\n        const contextData = ContextData()\n        contextData.unsafeInject(instance)\n        return contextData\n      },\n\n      /**\n       * The ContextData corresponding to the first encryption parameters that are used for data.\n       *\n       * @readonly\n       * @name Context#firstContextData\n       * @type {ContextData}\n       */\n      get firstContextData() {\n        const instance = _instance.firstContextData()\n        const contextData = ContextData()\n        contextData.unsafeInject(instance)\n        return contextData\n      },\n\n      /**\n       * Returns the ContextData corresponding to the last encryption parameters that are used for data.\n       *\n       * @readonly\n       * @name Context#lastContextData\n       * @type {ContextData}\n       */\n      get lastContextData() {\n        const instance = _instance.lastContextData()\n        const contextData = ContextData()\n        contextData.unsafeInject(instance)\n        return contextData\n      },\n\n      /**\n       * Whether the encryption parameters are set in a way that is considered valid by\n       * Microsoft SEAL, the variable parameters_set is set to true.\n       *\n       * @function\n       * @name Context#parametersSet\n       * @type {boolean}\n       */\n      parametersSet() {\n        return _instance.parametersSet()\n      },\n\n      /**\n       * Returns a ParmsIdType corresponding to the set of encryption parameters that are used for keys.\n       *\n       * @readonly\n       * @name Context#keyParmsId\n       * @type {ParmsIdType}\n       */\n      get keyParmsId() {\n        const instance = _instance.keyParmsId()\n        const parmsId = ParmsIdType()\n        parmsId.inject(instance)\n        return parmsId\n      },\n\n      /**\n       * Returns a ParmsIdType corresponding to the first encryption parameters that are used for data.\n       *\n       * @readonly\n       * @name Context#firstParmsId\n       * @type {ParmsIdType}\n       */\n      get firstParmsId() {\n        const instance = _instance.firstParmsId()\n        const parmsId = ParmsIdType()\n        parmsId.inject(instance)\n        return parmsId\n      },\n\n      /**\n       * The ParmsIdType corresponding to the last encryption parameters that are used for data.\n       *\n       * @readonly\n       * @name Context#lastParmsId\n       * @type {ParmsIdType}\n       */\n      get lastParmsId() {\n        const instance = _instance.lastParmsId()\n        const parmsId = ParmsIdType()\n        parmsId.inject(instance)\n        return parmsId\n      },\n\n      /**\n       * Whether the coefficient modulus supports keyswitching. In practice,\n       * support for keyswitching is required by Evaluator.relinearize,\n       * Evaluator.applyGalois, and all rotation and conjugation operations. For\n       * keyswitching to be available, the coefficient modulus parameter must consist\n       * of at least two prime number factors.\n       *\n       * @readonly\n       * @name Context#usingKeyswitching\n       * @type {boolean}\n       */\n      get usingKeyswitching() {\n        return _instance.usingKeyswitching()\n      }\n    }\n  }\n\nexport const ContextInit = ({ loader }: LoaderOptions): ContextDependencies => {\n  const library: Library = loader.library\n  return ContextConstructor(library)\n}\n","import {\n  EncryptionParameterQualifiers,\n  EncryptionParameterQualifiersConstructorOptions\n} from './encryption-parameter-qualifiers'\nimport {\n  EncryptionParameters,\n  EncryptionParametersConstructorOptions\n} from './encryption-parameters'\nimport { Exception } from './exception'\nimport { ParmsIdType, ParmsIdTypeConstructorOptions } from './parms-id-type'\nimport { Instance, Library, LoaderOptions } from './seal'\n\nexport type ContextDataDependencyOptions = {\n  readonly Exception: Exception\n  readonly EncryptionParameters: EncryptionParametersConstructorOptions\n  readonly ParmsIdType: ParmsIdTypeConstructorOptions\n  readonly EncryptionParameterQualifiers: EncryptionParameterQualifiersConstructorOptions\n}\n\nexport type ContextDataDependencies = {\n  ({\n    Exception,\n    EncryptionParameters,\n    ParmsIdType,\n    EncryptionParameterQualifiers\n  }: ContextDataDependencyOptions): ContextDataConstructorOptions\n}\n\nexport type ContextDataConstructorOptions = {\n  (): ContextData\n}\n\nexport type ContextData = {\n  readonly instance: Instance\n  readonly unsafeInject: (instance: Instance) => void\n  readonly delete: () => void\n  readonly parms: EncryptionParameters\n  readonly parmsId: ParmsIdType\n  readonly qualifiers: EncryptionParameterQualifiers\n  readonly totalCoeffModulusBitCount: number\n  readonly prevContextData: ContextData\n  readonly nextContextData: ContextData\n  readonly chainIndex: number\n}\n\nconst ContextDataConstructor =\n  (library: Library): ContextDataDependencies =>\n  ({\n    Exception,\n    EncryptionParameters,\n    ParmsIdType,\n    EncryptionParameterQualifiers\n  }: ContextDataDependencyOptions): ContextDataConstructorOptions =>\n  (): ContextData => {\n    let _instance: Instance\n    /**\n     * @implements ContextData\n     */\n\n    /**\n     * @interface ContextData\n     */\n    return {\n      /**\n       * Get the underlying WASM instance\n       *\n       * @private\n       * @readonly\n       * @name ContextData#instance\n       * @type {Instance}\n       */\n      get instance() {\n        return _instance\n      },\n\n      /**\n       * Inject this object with a raw WASM instance. No type checking is performed.\n       *\n       * @private\n       * @function\n       * @name ContextData#unsafeInject\n       * @param {Instance} instance WASM instance\n       */\n      unsafeInject(instance: Instance) {\n        if (_instance) {\n          _instance.delete()\n          _instance = undefined\n        }\n        _instance = instance\n      },\n\n      /**\n       * Delete the underlying WASM instance.\n       *\n       * Should be called before dereferencing this object to prevent the\n       * WASM heap from growing indefinitely.\n       * @function\n       * @name ContextData#delete\n       */\n      delete() {\n        if (_instance) {\n          _instance.delete()\n          _instance = undefined\n        }\n      },\n\n      /**\n       * Returns a const reference to the underlying encryption parameters.\n       *\n       * @readonly\n       * @name ContextData#parms\n       * @type {EncryptionParameters}\n       */\n      get parms() {\n        const instance = _instance.parms()\n        const encryptionParameters = EncryptionParameters()\n        encryptionParameters.unsafeInject(instance)\n        return encryptionParameters\n      },\n\n      /**\n       * Returns the parmsId of the current parameters.\n       *\n       * @readonly\n       * @name ContextData#parmsId\n       * @type {ParmsIdType}\n       */\n      get parmsId() {\n        const parms = ParmsIdType()\n        parms.inject(_instance.parmsId())\n        return parms\n      },\n\n      /**\n       * Returns a copy of EncryptionParameterQualifiers corresponding to the\n       * current encryption parameters. Note that to change the qualifiers it is\n       * necessary to create a new instance of SEALContext once appropriate changes\n       * to the encryption parameters have been made.\n       *\n       * @readonly\n       * @name ContextData#qualifiers\n       * @type {EncryptionParameterQualifiers}\n       */\n      get qualifiers() {\n        const encParmQualifiers = EncryptionParameterQualifiers()\n        encParmQualifiers.unsafeInject(_instance.qualifiers())\n        return encParmQualifiers\n      },\n\n      /**\n       * Returns the significant bit count of the total coefficient modulus.\n       *\n       * @readonly\n       * @name ContextData#totalCoeffModulusBitCount\n       * @type {number}\n       */\n      get totalCoeffModulusBitCount() {\n        return _instance.totalCoeffModulusBitCount()\n      },\n\n      /**\n       * Returns a shared_ptr to the context data corresponding to the previous parameters\n       * in the modulus switching chain. If the current data is the first one in the\n       * chain, then the result is nullptr.\n       *\n       * @readonly\n       * @name ContextData#prevContextData\n       * @type {ContextData}\n       */\n      get prevContextData() {\n        const cxtData = ContextDataConstructor(library)({\n          Exception,\n          EncryptionParameters,\n          ParmsIdType,\n          EncryptionParameterQualifiers\n        })()\n        cxtData.unsafeInject(_instance.prevContextData())\n        return cxtData\n      },\n\n      /**\n       * Returns a shared_ptr to the context data corresponding to the next parameters\n       * in the modulus switching chain. If the current data is the last one in the\n       * chain, then the result is nullptr.\n       *\n       * @readonly\n       * @name ContextData#nextContextData\n       * @type {ContextData}\n       */\n      get nextContextData() {\n        const cxtData = ContextDataConstructor(library)({\n          Exception,\n          EncryptionParameters,\n          ParmsIdType,\n          EncryptionParameterQualifiers\n        })()\n        cxtData.unsafeInject(_instance.nextContextData())\n        return cxtData\n      },\n\n      /**\n       * Returns the index of the parameter set in a chain. The initial parameters\n       * have index 0 and the index increases sequentially in the parameter chain.\n       *\n       * @readonly\n       * @name EncryptionParameterQualifiers#chainIndex\n       * @type {number}\n       */\n      get chainIndex() {\n        return _instance.chainIndex()\n      }\n    }\n  }\n\nexport const ContextDataInit = ({\n  loader\n}: LoaderOptions): ContextDataDependencies => {\n  const library: Library = loader.library\n  return ContextDataConstructor(library)\n}\n","import { CipherText } from './cipher-text'\nimport { Context } from './context'\nimport { Exception, SealError } from './exception'\nimport { PlainText, PlainTextConstructorOptions } from './plain-text'\nimport { Instance, Library, LoaderOptions } from './seal'\nimport { SecretKey } from './secret-key'\n\nexport type DecryptorDependencyOptions = {\n  readonly Exception: Exception\n  readonly PlainText: PlainTextConstructorOptions\n}\n\nexport type DecryptorDependencies = {\n  ({\n    Exception,\n    PlainText\n  }: DecryptorDependencyOptions): DecryptorConstructorOptions\n}\n\nexport type DecryptorConstructorOptions = {\n  (context: Context, secretKey: SecretKey): Decryptor\n}\n\nexport type Decryptor = {\n  readonly instance: Instance\n  readonly unsafeInject: (instance: Instance) => void\n  readonly delete: () => void\n  readonly decrypt: (\n    cipherText: CipherText,\n    plainText?: PlainText\n  ) => PlainText | void\n  readonly invariantNoiseBudget: (cipherText: CipherText) => number\n}\n\nconst DecryptorConstructor =\n  (library: Library): DecryptorDependencies =>\n  ({\n    Exception,\n    PlainText\n  }: DecryptorDependencyOptions): DecryptorConstructorOptions =>\n  (context, secretKey): Decryptor => {\n    const Constructor = library.Decryptor\n    let _instance: Instance\n    try {\n      _instance = new Constructor(context.instance, secretKey.instance)\n    } catch (e) {\n      throw Exception.safe(e as SealError)\n    }\n    /**\n     * @implements Decryptor\n     */\n\n    /**\n     * @interface Decryptor\n     */\n    return {\n      /**\n       * Get the underlying WASM instance\n       *\n       * @private\n       * @readonly\n       * @name Decryptor#instance\n       * @type {Instance}\n       */\n      get instance() {\n        return _instance\n      },\n\n      /**\n       * Inject this object with a raw WASM instance. No type checking is performed.\n       *\n       * @private\n       * @function\n       * @name Decryptor#unsafeInject\n       * @param {Instance} instance WASM instance\n       */\n      unsafeInject(instance: Instance) {\n        if (_instance) {\n          _instance.delete()\n          _instance = undefined\n        }\n        _instance = instance\n      },\n\n      /**\n       * Delete the underlying WASM instance.\n       *\n       * Should be called before dereferencing this object to prevent the\n       * WASM heap from growing indefinitely.\n       * @function\n       * @name Decryptor#delete\n       */\n      delete() {\n        if (_instance) {\n          _instance.delete()\n          _instance = undefined\n        }\n      },\n\n      /**\n       * Decrypts a CipherText and stores the result in the destination parameter.\n       *\n       * @function\n       * @name Decryptor#decrypt\n       * @param {CipherText} cipherText CipherText to decrypt\n       * @param {PlainText} [plainText] PlainText destination to store the decrypted result\n       * @returns {PlainText|void} Returns undefined if a PlainText was specified. Otherwise returns a\n       * PlainText containng the decrypted result\n       */\n      decrypt(cipherText: CipherText, plainText?: PlainText): PlainText | void {\n        try {\n          if (plainText) {\n            _instance.decrypt(cipherText.instance, plainText.instance)\n            return\n          }\n          const plain = PlainText()\n          _instance.decrypt(cipherText.instance, plain.instance)\n          return plain\n        } catch (e) {\n          throw Exception.safe(e as SealError)\n        }\n      },\n\n      /**\n       * Computes the invariant noise budget (in bits) of a CipherText. The invariant\n       * noise budget measures the amount of room there is for the noise to grow while\n       * ensuring correct decryptions. This function works only with the BFV scheme.\n       *\n       * @par Invariant Noise Budget\n       * The invariant noise polynomial of a CipherText is a rational coefficient\n       * polynomial, such that a CipherText decrypts correctly as long as the\n       * coefficients of the invariantnoise polynomial are of absolute value less\n       * than 1/2. Thus, we call the infinity-norm of the invariant noise polynomial\n       * the invariant noise, and for correct decryption requireit to be less than\n       * 1/2. If v denotes the invariant noise, we define the invariant noise budget\n       * as -log2(2v). Thus, the invariant noise budget starts from some initial\n       * value, which depends on the encryption parameters, and decreases when\n       * computations are performed. When the budget reaches zero, the CipherText\n       * becomes too noisy to decrypt correctly.\n       *\n       * @function\n       * @name Decryptor#invariantNoiseBudget\n       * @param {CipherText} cipherText CipherText to measure\n       * @returns {number} Invariant noise budget (in bits)\n       */\n      invariantNoiseBudget(cipherText: CipherText): number {\n        try {\n          return _instance.invariantNoiseBudget(cipherText.instance)\n        } catch (e) {\n          throw Exception.safe(e as SealError)\n        }\n      }\n    }\n  }\n\nexport const DecryptorInit = ({\n  loader\n}: LoaderOptions): DecryptorDependencies => {\n  const library: Library = loader.library\n  return DecryptorConstructor(library)\n}\n","import { ComprModeType } from './compr-mode-type'\nimport { Exception, SealError } from './exception'\nimport { Modulus, ModulusConstructorOptions } from './modulus'\nimport { ParmsIdType, ParmsIdTypeConstructorOptions } from './parms-id-type'\nimport { SchemeType } from './scheme-type'\nimport { Instance, Library, LoaderOptions } from './seal'\nimport { Vector, VectorConstructorOptions } from './vector'\n\nexport type EncryptionParametersDependencyOptions = {\n  readonly Exception: Exception\n  readonly ComprModeType: ComprModeType\n  readonly Modulus: ModulusConstructorOptions\n  readonly SchemeType: SchemeType\n  readonly ParmsIdType: ParmsIdTypeConstructorOptions\n  readonly Vector: VectorConstructorOptions\n}\n\nexport type EncryptionParametersDependencies = {\n  ({\n    Exception,\n    ComprModeType,\n    Modulus,\n    SchemeType,\n    Vector\n  }: EncryptionParametersDependencyOptions): EncryptionParametersConstructorOptions\n}\n\nexport type EncryptionParametersConstructorOptions = {\n  (schemeType?: SchemeType): EncryptionParameters\n}\n\nexport type EncryptionParameters = {\n  readonly instance: Instance\n  readonly unsafeInject: (instance: Instance) => void\n  readonly delete: () => void\n  readonly setPolyModulusDegree: (polyModulusDegree: number) => void\n  readonly setCoeffModulus: (coeffModulus: Vector) => void\n  readonly setPlainModulus: (plainModulus: Modulus) => void\n  readonly scheme: SchemeType\n  readonly polyModulusDegree: number\n  readonly coeffModulus: BigUint64Array\n  readonly plainModulus: Modulus\n  readonly parmsId: ParmsIdType\n  readonly save: (compression?: ComprModeType) => string\n  readonly saveArray: (compression?: ComprModeType) => Uint8Array\n  readonly load: (encoded: string) => void\n  readonly loadArray: (array: Uint8Array) => void\n}\n\nconst EncryptionParametersConstructor =\n  (library: Library): EncryptionParametersDependencies =>\n  ({\n    Exception,\n    ComprModeType,\n    Modulus,\n    SchemeType,\n    ParmsIdType,\n    Vector\n  }: EncryptionParametersDependencyOptions): EncryptionParametersConstructorOptions =>\n  (schemeType: SchemeType = SchemeType.none): EncryptionParameters => {\n    const Constructor = library.EncryptionParameters\n    let _instance = new Constructor(schemeType)\n\n    /**\n     * @implements EncryptionParameters\n     */\n\n    /**\n     * @interface EncryptionParameters\n     */\n    return {\n      /**\n       * Get the underlying WASM instance\n       *\n       * @private\n       * @readonly\n       * @name EncryptionParameters#instance\n       * @type {Instance}\n       */\n      get instance() {\n        return _instance\n      },\n\n      /**\n       * Inject this object with a raw WASM instance. No type checking is performed.\n       *\n       * @private\n       * @function\n       * @name EncryptionParameters#unsafeInject\n       * @param {Instance} instance WASM instance\n       */\n      unsafeInject(instance: Instance) {\n        if (_instance) {\n          _instance.delete()\n          _instance = undefined\n        }\n        _instance = instance\n      },\n\n      /**\n       * Delete the underlying WASM instance.\n       *\n       * Should be called before dereferencing this object to prevent the\n       * WASM heap from growing indefinitely.\n       * @function\n       * @name EncryptionParameters#delete\n       */\n      delete() {\n        if (_instance) {\n          _instance.delete()\n          _instance = undefined\n        }\n      },\n\n      /**\n       * Sets the degree of the polynomial modulus parameter to the specified value.\n       * The polynomial modulus directly affects the number of coefficients in\n       * PlainText polynomials, the size of CipherText elements, the computational\n       * performance of the scheme (bigger is worse), and the security level (bigger\n       * is better). In Microsoft SEAL the degree of the polynomial modulus must be a power\n       * of 2 (e.g.  1024, 2048, 4096, 8192, 16384, or 32768).\n       *\n       * @function\n       * @name EncryptionParameters#setPolyModulusDegree\n       * @param {number} polyModulusDegree The degree of the polynomial modulus\n       */\n      setPolyModulusDegree(polyModulusDegree: number) {\n        try {\n          _instance.setPolyModulusDegree(polyModulusDegree)\n        } catch (e) {\n          throw Exception.safe(e as SealError)\n        }\n      },\n\n      /**\n       * Sets the coefficient modulus parameter. The coefficient modulus consists\n       * of a list of distinct prime numbers, and is represented by a vector of\n       * Modulus objects. The coefficient modulus directly affects the size\n       * of CipherText elements, the amount of computation that the scheme can perform\n       * (bigger is better), and the security level (bigger is worse). In Microsoft SEAL each\n       * of the prime numbers in the coefficient modulus must be at most 60 bits,\n       * and must be congruent to 1 modulo 2*degree(poly_modulus).\n       *\n       * @function\n       * @name EncryptionParameters#setCoeffModulus\n       * @param {Vector} coeffModulus Vector of Modulus primes\n       */\n      setCoeffModulus(coeffModulus: Vector) {\n        try {\n          _instance.setCoeffModulus(coeffModulus.instance)\n        } catch (e) {\n          throw Exception.safe(e as SealError)\n        }\n      },\n\n      /**\n       * Sets the PlainText modulus parameter. The PlainText modulus is an integer\n       * modulus represented by the Modulus class. The PlainText modulus\n       * determines the largest coefficient that PlainText polynomials can represent.\n       * It also affects the amount of computation that the scheme can perform\n       * (bigger is worse). In Microsoft SEAL the PlainText modulus can be at most 60 bits\n       * long, but can otherwise be any integer. Note, however, that some features\n       * (e.g. batching) require the PlainText modulus to be of a particular form.\n       *\n       * @function\n       * @name EncryptionParameters#setPlainModulus\n       * @param {Modulus} plainModulus PlainText modulus parameter\n       */\n      setPlainModulus(plainModulus: Modulus) {\n        try {\n          _instance.setPlainModulus(plainModulus.instance)\n        } catch (e) {\n          throw Exception.safe(e as SealError)\n        }\n      },\n\n      /**\n       * The encryption scheme type.\n       *\n       * @readonly\n       * @name EncryptionParameters#scheme\n       * @type {SchemeType.none|SchemeType.bfv|SchemeType.ckks}\n       */\n      get scheme() {\n        return _instance.scheme()\n      },\n\n      /**\n       * The degree of the polynomial modulus parameter.\n       *\n       * @readonly\n       * @name EncryptionParameters#polyModulusDegree\n       * @type {number}\n       */\n      get polyModulusDegree() {\n        return _instance.polyModulusDegree()\n      },\n\n      /**\n       * Returns the currently set coefficient modulus parameter.\n       *\n       * @readonly\n       * @name EncryptionParameters#coeffModulus\n       * @type {BigUint64Array}\n       */\n      get coeffModulus() {\n        const tempVect = Vector()\n        const instance = _instance.coeffModulus()\n        tempVect.unsafeInject(instance)\n        tempVect.setType('Modulus')\n        const tempArr = tempVect.toArray() as BigUint64Array\n        tempVect.delete()\n        return tempArr\n      },\n\n      /**\n       * Returns the currently set PlainText modulus parameter.\n       *\n       * @readonly\n       * @name EncryptionParameters#plainModulus\n       * @type {Modulus}\n       */\n      get plainModulus() {\n        const instance = _instance.plainModulus()\n        const smallModulus = Modulus(BigInt(0))\n        smallModulus.inject(instance)\n        return smallModulus\n      },\n\n      /**\n       * Returns the ParmsId of the current parameters.\n       *\n       * @readonly\n       * @name EncryptionParameters#parmsId\n       * @type {ParmsIdType}\n       */\n      get parmsId() {\n        const parms = ParmsIdType()\n        parms.inject(_instance.parmsId())\n        return parms\n      },\n\n      /**\n       * Save the Encryption Parameters to a base64 string\n       *\n       * @function\n       * @name EncryptionParameters#save\n       * @param {ComprModeType} [compression={@link ComprModeType.zstd}] The compression mode to use\n       * @returns {string} base64 encoded string\n       */\n      save(compression: ComprModeType = ComprModeType.zstd): string {\n        return _instance.saveToString(compression)\n      },\n\n      /**\n       * Save the Encryption Parameters as a binary Uint8Array\n       *\n       * @function\n       * @name EncryptionParameters#saveArray\n       * @param {ComprModeType} [compression={@link ComprModeType.zstd}] The compression mode to use\n       * @returns {Uint8Array} A byte array containing the CipherText in binary form\n       */\n      saveArray(compression: ComprModeType = ComprModeType.zstd): Uint8Array {\n        const tempVect = Vector()\n        const instance = _instance.saveToArray(compression)\n        tempVect.unsafeInject(instance)\n        tempVect.setType('Uint8Array')\n        const tempArr = tempVect.toArray() as Uint8Array\n        tempVect.delete()\n        return tempArr\n      },\n\n      /**\n       * Load the Encryption Parameters from a base64 string\n       *\n       * @function\n       * @name EncryptionParameters#load\n       * @param {string} encoded base64 encoded string\n       */\n      load(encoded: string) {\n        try {\n          _instance.loadFromString(encoded)\n        } catch (e) {\n          throw Exception.safe(e as SealError)\n        }\n      },\n\n      /**\n       * Load the Encryption Parameters from an Uint8Array holding binary data\n       *\n       * @function\n       * @name EncryptionParameters#loadArray\n       * @param {Uint8Array} array TypedArray containing binary data\n       */\n      loadArray(array: Uint8Array) {\n        try {\n          _instance.loadFromArray(array)\n        } catch (e) {\n          throw Exception.safe(e as SealError)\n        }\n      }\n    }\n  }\n\nexport const EncryptionParametersInit = ({\n  loader\n}: LoaderOptions): EncryptionParametersDependencies => {\n  const library: Library = loader.library\n  return EncryptionParametersConstructor(library)\n}\n","import { CipherText, CipherTextConstructorOptions } from './cipher-text'\nimport { Context } from './context'\nimport { Exception, SealError } from './exception'\nimport { MemoryPoolHandle } from './memory-pool-handle'\nimport { PlainText } from './plain-text'\nimport { PublicKey } from './public-key'\nimport { Instance, Library, LoaderOptions } from './seal'\nimport { SecretKey } from './secret-key'\nimport { Serializable, SerializableConstructorOptions } from './serializable'\n\nexport type EncryptorDependencyOptions = {\n  readonly Exception: Exception\n  readonly MemoryPoolHandle: MemoryPoolHandle\n  readonly CipherText: CipherTextConstructorOptions\n  readonly Serializable: SerializableConstructorOptions\n}\n\nexport type EncryptorDependencies = {\n  ({\n    Exception,\n    MemoryPoolHandle,\n    CipherText,\n    Serializable\n  }: EncryptorDependencyOptions): EncryptorConstructorOptions\n}\n\nexport type EncryptorConstructorOptions = {\n  (context: Context, publicKey: PublicKey, secretKey?: SecretKey): Encryptor\n}\n\nexport type Encryptor = {\n  readonly instance: Instance\n  readonly unsafeInject: (instance: Instance) => void\n  readonly delete: () => void\n  readonly encrypt: (\n    plainText: PlainText,\n    cipherText?: CipherText,\n    pool?: MemoryPoolHandle\n  ) => CipherText | void\n  readonly encryptSerializable: (\n    plainText: PlainText,\n    pool?: MemoryPoolHandle\n  ) => Serializable\n  readonly encryptSymmetric: (\n    plainText: PlainText,\n    cipherText?: CipherText,\n    pool?: MemoryPoolHandle\n  ) => CipherText | void\n  readonly encryptSymmetricSerializable: (\n    plainText: PlainText,\n    pool?: MemoryPoolHandle\n  ) => Serializable\n  readonly encryptZero: (\n    cipherText?: CipherText,\n    pool?: MemoryPoolHandle\n  ) => CipherText | void\n  readonly encryptZeroSerializable: (pool?: MemoryPoolHandle) => Serializable\n}\n\nconst EncryptorConstructor =\n  (library: Library): EncryptorDependencies =>\n  ({\n    Exception,\n    MemoryPoolHandle,\n    CipherText,\n    Serializable\n  }: EncryptorDependencyOptions): EncryptorConstructorOptions =>\n  (context, publicKey, secretKey): Encryptor => {\n    const Constructor = library.Encryptor\n    let _instance = constructInstance(context, publicKey, secretKey)\n\n    function constructInstance(\n      context: Context,\n      publicKey: PublicKey,\n      secretKey?: SecretKey\n    ) {\n      try {\n        if (secretKey) {\n          return new Constructor(\n            context.instance,\n            publicKey.instance,\n            secretKey.instance\n          )\n        }\n        return new Constructor(context.instance, publicKey.instance)\n      } catch (e) {\n        throw Exception.safe(e as SealError)\n      }\n    }\n    /**\n     * @implements Encryptor\n     */\n\n    /**\n     * @interface Encryptor\n     */\n    return {\n      /**\n       * Get the underlying WASM instance\n       *\n       * @private\n       * @readonly\n       * @name Encryptor#instance\n       * @type {Instance}\n       */\n      get instance() {\n        return _instance\n      },\n\n      /**\n       * Inject this object with a raw WASM instance. No type checking is performed.\n       *\n       * @private\n       * @function\n       * @name Encryptor#unsafeInject\n       * @param {Instance} instance WASM instance\n       */\n      unsafeInject(instance: Instance) {\n        if (_instance) {\n          _instance.delete()\n          _instance = undefined\n        }\n        _instance = instance\n      },\n\n      /**\n       * Delete the underlying WASM instance.\n       *\n       * Should be called before dereferencing this object to prevent the\n       * WASM heap from growing indefinitely.\n       * @function\n       * @name Encryptor#delete\n       */\n      delete() {\n        if (_instance) {\n          _instance.delete()\n          _instance = undefined\n        }\n      },\n\n      /**\n       * Encrypts a PlainText and stores the result in the destination parameter.\n       * Dynamic memory allocations in the process are allocated from the memory\n       * pool pointed to by the given MemoryPoolHandle.\n       *\n       * @function\n       * @name Encryptor#encrypt\n       * @param {PlainText} plainText PlainText to encrypt\n       * @param {CipherText} [cipherText] CipherText destination to store the encrypted result\n       * @param {MemoryPoolHandle} [pool={@link MemoryPoolHandle.global}] MemoryPool to use\n       * @returns {CipherText|void} Returns undefined if a CipherText was specified. Otherwise returns a\n       * CipherText containing the encrypted result\n       */\n      encrypt(\n        plainText: PlainText,\n        cipherText?: CipherText,\n        pool: MemoryPoolHandle = MemoryPoolHandle.global\n      ): CipherText | void {\n        try {\n          if (cipherText) {\n            _instance.encrypt(plainText.instance, cipherText.instance, pool)\n            return\n          }\n          const cipher = CipherText()\n          _instance.encrypt(plainText.instance, cipher.instance, pool)\n          return cipher\n        } catch (e) {\n          throw Exception.safe(e as SealError)\n        }\n      },\n\n      /**\n       * Encrypts a PlainText and returns a CipherText as a Serializable object.\n       * Dynamic memory allocations in the process are allocated from the memory\n       * pool pointed to by the given MemoryPoolHandle.\n       *\n       * @function\n       * @name Encryptor#encryptSerializable\n       * @param {PlainText} plainText PlainText to encrypt\n       * @param {MemoryPoolHandle} [pool={@link MemoryPoolHandle.global}] MemoryPool to use\n       * @returns {Serializable<CipherText>} A Serializable containing the encrypted result\n       */\n      encryptSerializable(\n        plainText: PlainText,\n        pool: MemoryPoolHandle = MemoryPoolHandle.global\n      ): Serializable {\n        try {\n          const temp = Serializable()\n          const instance = _instance.encryptSerializable(\n            plainText.instance,\n            pool\n          )\n          temp.unsafeInject(instance)\n          return temp\n        } catch (e) {\n          throw Exception.safe(e as SealError)\n        }\n      },\n\n      /**\n       * Encrypts a PlainText with the secret key and stores the result in\n       * destination.\n       *\n       * The encryption parameters for the resulting CipherText\n       * correspond to:\n       * 1) in BFV or BGV, the highest (data) level in the modulus switching chain,\n       * 2) in CKKS, the encryption parameters of the plaintext.\n       * Dynamic memory allocations in the process are allocated from the memory\n       * pool pointed to by the given MemoryPoolHandle.\n       *\n       * @function\n       * @name Encryptor#encryptSymmetric\n       * @param {PlainText} plainText PlainText to encrypt\n       * @param {CipherText} [cipherText] CipherText destination to store the encrypted result.\n       * @param {MemoryPoolHandle} [pool={@link MemoryPoolHandle.global}] MemoryPool to use\n       * @returns {CipherText|void} Returns undefined if a CipherText was specified. Otherwise returns a\n       * CipherText containing the encrypted result\n       */\n      encryptSymmetric(\n        plainText: PlainText,\n        cipherText?: CipherText,\n        pool: MemoryPoolHandle = MemoryPoolHandle.global\n      ): CipherText | void {\n        try {\n          if (cipherText) {\n            _instance.encryptSymmetric(\n              plainText.instance,\n              cipherText.instance,\n              pool\n            )\n            return\n          }\n          const cipher = CipherText()\n          _instance.encryptSymmetric(plainText.instance, cipher.instance, pool)\n          return cipher\n        } catch (e) {\n          throw Exception.safe(e as SealError)\n        }\n      },\n\n      /**\n       * Encrypts a plaintext with the secret key and returns the ciphertext as\n       * a serializable object.\n       *\n       * The encryption parameters for the resulting CipherText\n       * correspond to:\n       * 1) in BFV or BGV, the highest (data) level in the modulus switching chain,\n       * 2) in CKKS, the encryption parameters of the plaintext.\n       * Dynamic memory allocations in the process are allocated from the memory\n       * pool pointed to by the given MemoryPoolHandle.\n       *\n       * Half of the ciphertext data is pseudo-randomly generated from a seed to\n       * reduce the object size. The resulting serializable object cannot be used\n       * directly and is meant to be serialized for the size reduction to have an\n       * impact.\n       *\n       * @function\n       * @name Encryptor#encryptSymmetricSerializable\n       * @param {PlainText} plainText PlainText to encrypt\n       * @param {MemoryPoolHandle} [pool={@link MemoryPoolHandle.global}] MemoryPool to use\n       * @returns {Serializable<CipherText>} Returns a Serializable containing the encrypted result\n       */\n      encryptSymmetricSerializable(\n        plainText: PlainText,\n        pool: MemoryPoolHandle = MemoryPoolHandle.global\n      ): Serializable {\n        try {\n          const serialized = Serializable()\n          const instance = _instance.encryptSymmetricSerializable(\n            plainText.instance,\n            pool\n          )\n          serialized.unsafeInject(instance)\n          return serialized\n        } catch (e) {\n          throw Exception.safe(e as SealError)\n        }\n      },\n\n      /**\n       * Encrypts a zero plaintext with the public key and returns the ciphertext\n       * as a serializable object.\n       *\n       * The encryption parameters for the resulting ciphertext correspond to the\n       * highest (data) level in the modulus switching chain. Dynamic memory\n       * allocations in the process are allocated from the memory pool pointed to\n       * by the given MemoryPoolHandle.\n       *\n       * @function\n       * @name Encryptor#encryptZero\n       * @param {CipherText} [cipherText] A CipherText to overwrite.\n       * @param {MemoryPoolHandle} [pool={@link MemoryPoolHandle.global}] MemoryPool to use\n       * @returns {CipherText|void} Returns undefined if a CipherText was specified. Otherwise returns a\n       * CipherText containing the encrypted result\n       */\n      encryptZero(\n        cipherText?: CipherText,\n        pool: MemoryPoolHandle = MemoryPoolHandle.global\n      ): CipherText | void {\n        try {\n          if (cipherText) {\n            _instance.encryptZero(cipherText.instance, pool)\n            return\n          }\n          const cipher = CipherText()\n          _instance.encryptZero(cipher.instance, pool)\n          return cipher\n        } catch (e) {\n          throw Exception.safe(e as SealError)\n        }\n      },\n\n      /**\n       * Encrypts a zero plaintext with the public key and stores the result in\n       * destination.\n       *\n       * The encryption parameters for the resulting ciphertext correspond to the\n       * highest (data) level in the modulus switching chain. Dynamic memory\n       * allocations in the process are allocated from the memory pool pointed to\n       * by the given MemoryPoolHandle.\n       *\n       * @function\n       * @name Encryptor#encryptZeroSerializable\n       * @param {MemoryPoolHandle} [pool={@link MemoryPoolHandle.global}] MemoryPool to use\n       * @returns {Serializable<CipherText>} A CipherText as a serialized object containing the encrypted result\n       */\n      encryptZeroSerializable(\n        pool: MemoryPoolHandle = MemoryPoolHandle.global\n      ): Serializable {\n        try {\n          const serialized = Serializable()\n          const instance = _instance.encryptZeroSerializable(pool)\n          serialized.unsafeInject(instance)\n          return serialized\n        } catch (e) {\n          throw Exception.safe(e as SealError)\n        }\n      }\n    }\n  }\n\nexport const EncryptorInit = ({\n  loader\n}: LoaderOptions): EncryptorDependencies => {\n  const library: Library = loader.library\n  return EncryptorConstructor(library)\n}\n","import { CipherText, CipherTextConstructorOptions } from './cipher-text'\nimport { Context } from './context'\nimport { Exception, SealError } from './exception'\nimport { GaloisKeys } from './galois-keys'\nimport { MemoryPoolHandle } from './memory-pool-handle'\nimport { ParmsIdType } from './parms-id-type'\nimport { PlainText, PlainTextConstructorOptions } from './plain-text'\nimport { RelinKeys } from './relin-keys'\nimport { SchemeType } from './scheme-type'\nimport { Instance, Library, LoaderOptions } from './seal'\n\nexport type EvaluatorDependencyOptions = {\n  readonly Exception: Exception\n  readonly MemoryPoolHandle: MemoryPoolHandle\n  readonly CipherText: CipherTextConstructorOptions\n  readonly PlainText: PlainTextConstructorOptions\n}\n\nexport type EvaluatorDependencies = {\n  ({\n    Exception,\n    MemoryPoolHandle,\n    CipherText,\n    PlainText\n  }: EvaluatorDependencyOptions): EvaluatorConstructorOptions\n}\n\nexport type EvaluatorConstructorOptions = {\n  (context: Context): Evaluator\n}\n\nexport type Evaluator = {\n  readonly instance: Instance\n  readonly unsafeInject: (instance: Instance) => void\n  readonly delete: () => void\n  readonly negate: (\n    encrypted: CipherText,\n    destination?: CipherText\n  ) => CipherText | void\n  readonly add: (\n    a: CipherText,\n    b: CipherText,\n    destination?: CipherText\n  ) => CipherText | void\n  readonly sub: (\n    a: CipherText,\n    b: CipherText,\n    destination?: CipherText\n  ) => CipherText | void\n  readonly multiply: (\n    a: CipherText,\n    b: CipherText,\n    destination?: CipherText,\n    pool?: MemoryPoolHandle\n  ) => CipherText | void\n  readonly square: (\n    encrypted: CipherText,\n    destination?: CipherText,\n    pool?: MemoryPoolHandle\n  ) => CipherText | void\n  readonly relinearize: (\n    encrypted: CipherText,\n    relinKeys: RelinKeys,\n    destination?: CipherText,\n    pool?: MemoryPoolHandle\n  ) => CipherText | void\n  readonly cipherModSwitchToNext: (\n    encrypted: CipherText,\n    destination?: CipherText,\n    pool?: MemoryPoolHandle\n  ) => CipherText | void\n  readonly cipherModSwitchTo: (\n    encrypted: CipherText,\n    parmsId: ParmsIdType,\n    destination?: CipherText,\n    pool?: MemoryPoolHandle\n  ) => CipherText | void\n  readonly plainModSwitchToNext: (\n    plain: PlainText,\n    destination?: PlainText\n  ) => PlainText | void\n  readonly plainModSwitchTo: (\n    plain: PlainText,\n    parmsId: ParmsIdType,\n    destination?: PlainText\n  ) => PlainText | void\n  readonly rescaleToNext: (\n    encrypted: CipherText,\n    destination?: CipherText,\n    pool?: MemoryPoolHandle\n  ) => CipherText | void\n  readonly rescaleTo: (\n    encrypted: CipherText,\n    parmsId: ParmsIdType,\n    destination?: CipherText,\n    pool?: MemoryPoolHandle\n  ) => CipherText | void\n  readonly modReduceToNext: (\n    encrypted: CipherText,\n    destination?: CipherText,\n    pool?: MemoryPoolHandle\n  ) => CipherText | void\n  readonly modReduceTo: (\n    encrypted: CipherText,\n    parmsId: ParmsIdType,\n    destination?: CipherText,\n    pool?: MemoryPoolHandle\n  ) => CipherText | void\n  readonly exponentiate: (\n    encrypted: CipherText,\n    exponent: number,\n    relinKeys: RelinKeys,\n    destination?: CipherText,\n    pool?: MemoryPoolHandle\n  ) => CipherText | void\n  readonly addPlain: (\n    encrypted: CipherText,\n    plain: PlainText,\n    destination?: CipherText,\n    pool?: MemoryPoolHandle\n  ) => CipherText | void\n  readonly subPlain: (\n    encrypted: CipherText,\n    plain: PlainText,\n    destination?: CipherText,\n    pool?: MemoryPoolHandle\n  ) => CipherText | void\n  readonly multiplyPlain: (\n    encrypted: CipherText,\n    plain: PlainText,\n    destination?: CipherText,\n    pool?: MemoryPoolHandle\n  ) => CipherText | void\n  readonly plainTransformToNtt: (\n    plain: PlainText,\n    parmsId: ParmsIdType,\n    destinationNtt?: PlainText,\n    pool?: MemoryPoolHandle\n  ) => PlainText | void\n  readonly cipherTransformToNtt: (\n    encrypted: CipherText,\n    destinationNtt?: CipherText\n  ) => CipherText | void\n  readonly cipherTransformFromNtt: (\n    encryptedNtt: CipherText,\n    destination?: CipherText\n  ) => CipherText | void\n  readonly applyGalois: (\n    encrypted: CipherText,\n    galoisElt: number,\n    galoisKeys: GaloisKeys,\n    destination?: CipherText,\n    pool?: MemoryPoolHandle\n  ) => CipherText | void\n  readonly rotateRows: (\n    encrypted: CipherText,\n    steps: number,\n    galoisKeys: GaloisKeys,\n    destination?: CipherText,\n    pool?: MemoryPoolHandle\n  ) => CipherText | void\n  readonly rotateColumns: (\n    encrypted: CipherText,\n    galoisKeys: GaloisKeys,\n    destination?: CipherText,\n    pool?: MemoryPoolHandle\n  ) => CipherText | void\n  readonly rotateVector: (\n    encrypted: CipherText,\n    steps: number,\n    galoisKeys: GaloisKeys,\n    destination?: CipherText,\n    pool?: MemoryPoolHandle\n  ) => CipherText | void\n  readonly complexConjugate: (\n    encrypted: CipherText,\n    galoisKeys: GaloisKeys,\n    destination?: CipherText,\n    pool?: MemoryPoolHandle\n  ) => CipherText | void\n  readonly sumElements: (\n    encrypted: CipherText,\n    galoisKeys: GaloisKeys,\n    scheme: SchemeType,\n    destination?: CipherText,\n    pool?: MemoryPoolHandle\n  ) => CipherText | void\n  readonly dotProduct: (\n    a: CipherText,\n    b: CipherText,\n    relinKeys: RelinKeys,\n    galoisKeys: GaloisKeys,\n    scheme: SchemeType,\n    destination?: CipherText,\n    pool?: MemoryPoolHandle\n  ) => CipherText | void\n  readonly dotProductPlain: (\n    a: CipherText,\n    b: PlainText,\n    galoisKeys: GaloisKeys,\n    scheme: SchemeType,\n    destination?: CipherText,\n    pool?: MemoryPoolHandle\n  ) => CipherText | void\n}\n\nconst EvaluatorConstructor =\n  (library: Library): EvaluatorDependencies =>\n  ({\n    Exception,\n    MemoryPoolHandle,\n    CipherText,\n    PlainText\n  }: EvaluatorDependencyOptions): EvaluatorConstructorOptions =>\n  (context): Evaluator => {\n    const Constructor = library.Evaluator\n    let _instance: Instance\n    try {\n      _instance = new Constructor(context.instance)\n    } catch (e) {\n      throw Exception.safe(e as SealError)\n    }\n    /**\n     * @implements Evaluator\n     */\n\n    /**\n     * @interface Evaluator\n     */\n    return {\n      /**\n       * Get the underlying WASM instance\n       *\n       * @private\n       * @readonly\n       * @name Evaluator#instance\n       * @type {Instance}\n       */\n      get instance() {\n        return _instance\n      },\n\n      /**\n       * Inject this object with a raw WASM instance. No type checking is performed.\n       *\n       * @private\n       * @function\n       * @name Evaluator#unsafeInject\n       * @param {Instance} instance WASM instance\n       */\n      unsafeInject(instance: Instance) {\n        if (_instance) {\n          _instance.delete()\n          _instance = undefined\n        }\n        _instance = instance\n      },\n\n      /**\n       * Delete the underlying WASM instance.\n       *\n       * Should be called before dereferencing this object to prevent the\n       * WASM heap from growing indefinitely.\n       * @function\n       * @name Evaluator#delete\n       */\n      delete() {\n        if (_instance) {\n          _instance.delete()\n          _instance = undefined\n        }\n      },\n\n      /**\n       * Negates a CipherText and stores the result in the destination parameter.\n       *\n       * @function\n       * @name Evaluator#negate\n       * @param {CipherText} encrypted CipherText to negate\n       * @param {CipherText} [destination] CipherText to store the negated results\n       * @returns {CipherText|void} CipherText containing the result or void if a destination was supplied\n       * @example\n       * const cipherText = seal.CipherText()\n       * // ... after encrypting some data ...\n       * const resultCipher = evaluator.negate(cipherText)\n       * // or\n       * const cipherDest = seal.CipherText()\n       * evaluator.negate(encrypted, cipherDest)\n       */\n      negate(\n        encrypted: CipherText,\n        destination?: CipherText\n      ): CipherText | void {\n        try {\n          if (destination) {\n            _instance.negate(encrypted.instance, destination.instance)\n            return\n          }\n          const temp = CipherText()\n          _instance.negate(encrypted.instance, temp.instance)\n          return temp\n        } catch (e) {\n          throw Exception.safe(e as SealError)\n        }\n      },\n\n      /**\n       * Adds two CipherTexts. This function adds together a and b\n       * and stores the result in the destination parameter.\n       *\n       * @function\n       * @name Evaluator#add\n       * @param {CipherText} a CipherText operand A\n       * @param {CipherText} b CipherText operand B\n       * @param {CipherText} [destination] CipherText destination to store the sum\n       * @returns {CipherText|void} CipherText containing the result or void if a destination was supplied\n       * @example\n       * const cipherTextA = seal.CipherText()\n       * const cipherTextB = seal.CipherText()\n       * // ... after encrypting some data ...\n       * const resultCipher = evaluator.add(cipherTextA, cipherTextB)\n       * // or\n       * const cipherDest = seal.CipherText()\n       * evaluator.add(cipherTextA, cipherTextB, cipherDest)\n       */\n      add(\n        a: CipherText,\n        b: CipherText,\n        destination?: CipherText\n      ): CipherText | void {\n        try {\n          if (destination) {\n            _instance.add(a.instance, b.instance, destination.instance)\n            return\n          }\n          const temp = CipherText()\n          _instance.add(a.instance, b.instance, temp.instance)\n          return temp\n        } catch (e) {\n          throw Exception.safe(e as SealError)\n        }\n      },\n\n      /**\n       * Subtracts two CipherTexts. This function computes the difference of a\n       * and b and stores the result in the destination parameter.\n       *\n       * @function\n       * @name Evaluator#sub\n       * @param {CipherText} a CipherText operand A\n       * @param {CipherText} b CipherText operand B\n       * @param {CipherText} [destination] CipherText destination to store the difference\n       * @returns {CipherText|void} CipherText containing the result or void if a destination was supplied\n       * @example\n       * const cipherTextA = seal.CipherText()\n       * const cipherTextB = seal.CipherText()\n       * // ... after encrypting some data ...\n       * const resultCipher = evaluator.sub(cipherTextA, cipherTextB)\n       * // or\n       * const cipherDest = seal.CipherText()\n       * evaluator.sub(cipherTextA, cipherTextB, cipherDest)\n       */\n      sub(\n        a: CipherText,\n        b: CipherText,\n        destination?: CipherText\n      ): CipherText | void {\n        try {\n          if (destination) {\n            _instance.sub(a.instance, b.instance, destination.instance)\n            return\n          }\n          const temp = CipherText()\n          _instance.sub(a.instance, b.instance, temp.instance)\n          return temp\n        } catch (e) {\n          throw Exception.safe(e as SealError)\n        }\n      },\n\n      /**\n       * Multiplies two CipherTexts. This functions computes the product of a\n       * and b and stores the result in the destination parameter. Dynamic\n       * memory allocations in the process are allocated from the memory pool pointed\n       * to by the given MemoryPoolHandle.\n       *\n       * @function\n       * @name Evaluator#multiply\n       * @param {CipherText} a CipherText operand A\n       * @param {CipherText} b CipherText operand B\n       * @param {CipherText} [destination] CipherText destination to store the product\n       * @param {MemoryPoolHandle} [pool={@link MemoryPoolHandle.global}] MemoryPool to use\n       * @returns {CipherText|void} CipherText containing the result or void if a destination was supplied\n       * @example\n       * const cipherTextA = seal.CipherText()\n       * const cipherTextB = seal.CipherText()\n       * // ... after encrypting some data ...\n       * const resultCipher = evaluator.multiply(cipherTextA, cipherTextB)\n       * // or\n       * const cipherDest = seal.CipherText()\n       * evaluator.multiply(cipherTextA, cipherTextB, cipherDest)\n       */\n      multiply(\n        a: CipherText,\n        b: CipherText,\n        destination?: CipherText,\n        pool: MemoryPoolHandle = MemoryPoolHandle.global\n      ): CipherText | void {\n        try {\n          if (destination) {\n            _instance.multiply(\n              a.instance,\n              b.instance,\n              destination.instance,\n              pool\n            )\n            return\n          }\n          const temp = CipherText()\n          _instance.multiply(a.instance, b.instance, temp.instance, pool)\n          return temp\n        } catch (e) {\n          throw Exception.safe(e as SealError)\n        }\n      },\n\n      /**\n       * Squares a CipherText. This functions computes the square of encrypted and\n       * stores the result in the destination parameter. Dynamic memory allocations\n       * in the process are allocated from the memory pool pointed to by the given\n       * MemoryPoolHandle.\n       *\n       * @function\n       * @name Evaluator#square\n       * @param {CipherText} encrypted CipherText to square\n       * @param {CipherText} [destination] CipherText destination to store the squared result\n       * @param {MemoryPoolHandle} [pool={@link MemoryPoolHandle.global}] MemoryPool to use\n       * @returns {CipherText|void} CipherText containing the result or void if a destination was supplied\n       * @example\n       * const cipherTextA = seal.CipherText()\n       * // ... after encrypting some data ...\n       * const resultCipher = evaluator.square(cipherTextA, cipherTextB)\n       * // or\n       * const cipherDest = seal.CipherText()\n       * evaluator.square(cipherTextA, cipherDest)\n       */\n      square(\n        encrypted: CipherText,\n        destination?: CipherText,\n        pool: MemoryPoolHandle = MemoryPoolHandle.global\n      ): CipherText | void {\n        try {\n          if (destination) {\n            _instance.square(encrypted.instance, destination.instance, pool)\n            return\n          }\n          const temp = CipherText()\n          _instance.square(encrypted.instance, temp.instance, pool)\n          return temp\n        } catch (e) {\n          throw Exception.safe(e as SealError)\n        }\n      },\n\n      /**\n       * Relinearizes a CipherText. This functions relinearizes encrypted, reducing\n       * its size down to 2, and stores the result in the destination parameter.\n       * If the size of encrypted is K+1, the given relinearization keys need to\n       * have size at least K-1. Dynamic memory allocations in the process are allocated\n       * from the memory pool pointed to by the given MemoryPoolHandle.\n       *\n       * @function\n       * @name Evaluator#relinearize\n       * @param {CipherText} encrypted CipherText to relinearize\n       * @param {RelinKeys} relinKeys RelinKey used to perform relinearization\n       * @param {CipherText} [destination] CipherText destination to store the relinearized result\n       * @param {MemoryPoolHandle} [pool={@link MemoryPoolHandle.global}] MemoryPool to use\n       * @returns {CipherText|void} CipherText containing the result or void if a destination was supplied\n       * @example\n       * const relinKeys = keyGenerator.createRelinKeys()\n       * const cipherTextA = seal.CipherText()\n       * // ... after encrypting some data ...\n       * const resultCipher = evaluator.relinearize(cipherTextA, relinKeys)\n       * // or\n       * const cipherDest = seal.CipherText()\n       * evaluator.relinearize(cipherTextA, relinKeys, cipherDest)\n       */\n      relinearize(\n        encrypted: CipherText,\n        relinKeys: RelinKeys,\n        destination?: CipherText,\n        pool: MemoryPoolHandle = MemoryPoolHandle.global\n      ): CipherText | void {\n        try {\n          if (destination) {\n            _instance.relinearize(\n              encrypted.instance,\n              relinKeys.instance,\n              destination.instance,\n              pool\n            )\n            return\n          }\n          const temp = CipherText()\n          _instance.relinearize(\n            encrypted.instance,\n            relinKeys.instance,\n            temp.instance,\n            pool\n          )\n          return temp\n        } catch (e) {\n          throw Exception.safe(e as SealError)\n        }\n      },\n\n      /**\n       * Given a CipherText encrypted modulo q_1...q_k, this function switches the\n       * modulus down to q_1...q_{k-1} and stores the result in the destination\n       * parameter. Dynamic memory allocations in the process are allocated from\n       * the memory pool pointed to by the given MemoryPoolHandle.\n       *\n       * @function\n       * @name Evaluator#cipherModSwitchToNext\n       * @param {CipherText} encrypted CipherText to switch its modulus down\n       * @param {CipherText} [destination] CipherText destination to store the switched result\n       * @param {MemoryPoolHandle} [pool={@link MemoryPoolHandle.global}] MemoryPool to use\n       * @returns {CipherText|void} CipherText containing the result or void if a destination was supplied\n       * @example\n       * const cipherTextA = seal.CipherText()\n       * // ... after encrypting some data ...\n       * const resultCipher = evaluator.cipherModSwitchToNext(cipherTextA)\n       * // or\n       * const cipherDest = seal.CipherText()\n       * evaluator.cipherModSwitchToNext(cipherTextA, cipherDest)\n       */\n      cipherModSwitchToNext(\n        encrypted: CipherText,\n        destination?: CipherText,\n        pool: MemoryPoolHandle = MemoryPoolHandle.global\n      ): CipherText | void {\n        try {\n          if (destination) {\n            _instance.cipherModSwitchToNext(\n              encrypted.instance,\n              destination.instance,\n              pool\n            )\n            return\n          }\n          const temp = CipherText()\n          _instance.cipherModSwitchToNext(\n            encrypted.instance,\n            temp.instance,\n            pool\n          )\n          return temp\n        } catch (e) {\n          throw Exception.safe(e as SealError)\n        }\n      },\n\n      /**\n       * Given a CipherText encrypted modulo q_1...q_k, this function switches the\n       * modulus down until the parameters reach the given parmsId and stores the\n       * result in the destination parameter. Dynamic memory allocations in the process\n       * are allocated from the memory pool pointed to by the given MemoryPoolHandle.\n       *\n       * @function\n       * @name Evaluator#cipherModSwitchTo\n       * @param {CipherText} encrypted CipherText to switch its modulus down\n       * @param {ParmsIdType} parmsId Target parmsId to switch to\n       * @param {CipherText} [destination] CipherText destination to store the switched result\n       * @param {MemoryPoolHandle} [pool={@link MemoryPoolHandle.global}] MemoryPool to use\n       * @returns {CipherText|void} CipherText containing the result or void if a destination was supplied\n       * @example\n       * const context = seal.Context(encParms, true)\n       * const cipherTextA = seal.CipherText()\n       * // ... after encrypting some data ...\n       * const parmsId = context.lastParmsId\n       * const resultCipher = evaluator.cipherModSwitchTo(cipherTextA, parmsId)\n       * // or\n       * const cipherDest = seal.CipherText()\n       * evaluator.cipherModSwitchTo(cipherTextA, parmsId, cipherDest)\n       */\n      cipherModSwitchTo(\n        encrypted: CipherText,\n        parmsId: ParmsIdType,\n        destination?: CipherText,\n        pool: MemoryPoolHandle = MemoryPoolHandle.global\n      ): CipherText | void {\n        try {\n          if (destination) {\n            _instance.cipherModSwitchTo(\n              encrypted.instance,\n              parmsId.instance,\n              destination.instance,\n              pool\n            )\n            return\n          }\n          const temp = CipherText()\n          _instance.cipherModSwitchTo(\n            encrypted.instance,\n            parmsId.instance,\n            temp.instance,\n            pool\n          )\n          return temp\n        } catch (e) {\n          throw Exception.safe(e as SealError)\n        }\n      },\n\n      /**\n       * Modulus switches an NTT transformed PlainText from modulo q_1...q_k down\n       * to modulo q_1...q_{k-1} and stores the result in the destination parameter.\n       *\n       * @function\n       * @name Evaluator#plainModSwitchToNext\n       * @param {PlainText} plain PlainText to switch its modulus down\n       * @param {PlainText} [destination] PlainText destination to store the switched result\n       * @returns {PlainText|void} PlainText containing the result or void if a destination was supplied\n       * @example\n       * const plainTextA = seal.PlainText()\n       * // ... after encoding some data ...\n       * const resultCipher = evaluator.plainModSwitchToNext(plainTextA)\n       * // or\n       * const plainDest = seal.PlainText()\n       * evaluator.plainModSwitchToNext(plainTextA, plainDest)\n       */\n      plainModSwitchToNext(\n        plain: PlainText,\n        destination?: PlainText\n      ): PlainText | void {\n        try {\n          if (destination) {\n            _instance.plainModSwitchToNext(plain.instance, destination.instance)\n            return\n          }\n          const temp = PlainText()\n          _instance.plainModSwitchToNext(plain.instance, temp.instance)\n          return temp\n        } catch (e) {\n          throw Exception.safe(e as SealError)\n        }\n      },\n\n      /**\n       * Given an NTT transformed PlainText modulo q_1...q_k, this function switches\n       * the modulus down until the parameters reach the given parmsId and stores\n       * the result in the destination parameter.\n       *\n       * @function\n       * @name Evaluator#plainModSwitchTo\n       * @param {PlainText} plain PlainText to switch its modulus down\n       * @param {ParmsIdType} parmsId Target parmsId to switch to\n       * @param {PlainText} [destination] PlainText destination to store the switched result\n       * @returns {PlainText|void} PlainText containing the result or void if a destination was supplied\n       * @example\n       * const context = seal.Context(encParms, true)\n       * const plainTextA = seal.PlainText()\n       * // ... after encoding some data ...\n       * const parmsId = context.lastParmsId\n       * const resultCipher = evaluator.plainModSwitchTo(plainTextA, parmsId)\n       * // or\n       * const plainDest = seal.PlainText()\n       * evaluator.plainModSwitchTo(plainTextA, parmsId, plainDest)\n       */\n      plainModSwitchTo(\n        plain: PlainText,\n        parmsId: ParmsIdType,\n        destination?: PlainText\n      ): PlainText | void {\n        try {\n          if (destination) {\n            _instance.plainModSwitchTo(\n              plain.instance,\n              parmsId.instance,\n              destination.instance\n            )\n            return\n          }\n          const temp = PlainText()\n          _instance.plainModSwitchTo(\n            plain.instance,\n            parmsId.instance,\n            temp.instance\n          )\n          return temp\n        } catch (e) {\n          throw Exception.safe(e as SealError)\n        }\n      },\n\n      /**\n       * Given a CipherText encrypted modulo q_1...q_k, this function switches the\n       * modulus down to q_1...q_{k-1}, scales the message down accordingly, and\n       * stores the result in the destination parameter. Dynamic memory allocations\n       * in the process are allocated from the memory pool pointed to by the given\n       * MemoryPoolHandle.\n       *\n       * @function\n       * @name Evaluator#rescaleToNext\n       * @param {CipherText} encrypted CipherText to rescale\n       * @param {CipherText} [destination] CipherText destination to store the rescaled result\n       * @param {MemoryPoolHandle} [pool={@link MemoryPoolHandle.global}] MemoryPool to use\n       * @returns {CipherText|void} CipherText containing the result or void if a destination was supplied\n       * @example\n       * const cipherTextA = seal.CipherText()\n       * // ... after encrypting some data ...\n       * const resultCipher = evaluator.rescaleToNext(cipherTextA)\n       * // or\n       * const cipherDest = seal.CipherText()\n       * evaluator.rescaleToNext(cipherTextA, cipherDest)\n       */\n      rescaleToNext(\n        encrypted: CipherText,\n        destination?: CipherText,\n        pool: MemoryPoolHandle = MemoryPoolHandle.global\n      ): CipherText | void {\n        try {\n          if (destination) {\n            _instance.rescaleToNext(\n              encrypted.instance,\n              destination.instance,\n              pool\n            )\n            return\n          }\n          const temp = CipherText()\n          _instance.rescaleToNext(encrypted.instance, temp.instance, pool)\n          return temp\n        } catch (e) {\n          throw Exception.safe(e as SealError)\n        }\n      },\n\n      /**\n       * Given a CipherText encrypted modulo q_1...q_k, this function switches the\n       * modulus down until the parameters reach the given parmsId, scales the message\n       * down accordingly, and stores the result in the destination parameter. Dynamic\n       * memory allocations in the process are allocated from the memory pool pointed\n       * to by the given MemoryPoolHandle.\n       *\n       * @function\n       * @name Evaluator#rescaleTo\n       * @param {CipherText} encrypted CipherText to rescale\n       * @param {ParmsIdType} parmsId Target parmsId to rescale to\n       * @param {CipherText} [destination] CipherText destination to store the rescaled result\n       * @param {MemoryPoolHandle} [pool={@link MemoryPoolHandle.global}] MemoryPool to use\n       * @returns {CipherText|void} CipherText containing the result or void if a destination was supplied\n       * @example\n       * const context = seal.Context(encParms, true)\n       * const cipherTextA = seal.CipherText()\n       * // ... after encrypting some data ...\n       * const parmsId = context.lastParmsId\n       * const resultCipher = evaluator.rescaleTo(cipherTextA, parmsId)\n       * // or\n       * const cipherDest = seal.CipherText()\n       * evaluator.rescaleTo(cipherTextA, parmsId, cipherDest)\n       */\n      rescaleTo(\n        encrypted: CipherText,\n        parmsId: ParmsIdType,\n        destination?: CipherText,\n        pool: MemoryPoolHandle = MemoryPoolHandle.global\n      ): CipherText | void {\n        try {\n          if (destination) {\n            _instance.rescaleTo(\n              encrypted.instance,\n              parmsId.instance,\n              destination.instance,\n              pool\n            )\n            return\n          }\n          const temp = CipherText()\n          _instance.rescaleTo(\n            encrypted.instance,\n            parmsId.instance,\n            temp.instance,\n            pool\n          )\n          return temp\n        } catch (e) {\n          throw Exception.safe(e as SealError)\n        }\n      },\n\n      /**\n       * Given a ciphertext encrypted modulo q_1...q_k, this function switches\n       * the modulus down to q_1...q_{k-1}, scales the message down accordingly,\n       * and stores the result in the destination parameter. Dynamic memory\n       * allocations in the process are allocated from the memory pool pointed\n       * to by the given MemoryPoolHandle.\n       *\n       * @function\n       * @name Evaluator#modReduceToNext\n       * @param {CipherText} encrypted CipherText to reduce\n       * @param {CipherText} [destination] CipherText destination to store the\n       * reduced result\n       * @param {MemoryPoolHandle} [pool={@link MemoryPoolHandle.global}]\n       * MemoryPool to use\n       * @returns {CipherText|void} CipherText containing the result or void if\n       * a destination was supplied\n       * @example\n       * const cipherTextA = seal.CipherText()\n       * // ... after encrypting some data ...\n       * const resultCipher = evaluator.modReduceToNext(cipherTextA)\n       * // or\n       * const cipherDest = seal.CipherText()\n       * evaluator.modReduceToNext(cipherTextA, cipherDest)\n       */\n      modReduceToNext(\n        encrypted: CipherText,\n        destination?: CipherText,\n        pool: MemoryPoolHandle = MemoryPoolHandle.global\n      ): CipherText | void {\n        try {\n          if (destination) {\n            _instance.modReduceToNext(\n              encrypted.instance,\n              destination.instance,\n              pool\n            )\n            return\n          }\n          const temp = CipherText()\n          _instance.modReduceToNext(encrypted.instance, temp.instance, pool)\n          return temp\n        } catch (e) {\n          throw Exception.safe(e as SealError)\n        }\n      },\n\n      /**\n       * Given a ciphertext encrypted modulo q_1...q_k, this function reduces\n       * the modulus down until the parameters reach the given parms_id and\n       * stores the result in the destination parameter. Dynamic memory\n       * allocations in the process are allocated from the memory pool pointed\n       * to by the given MemoryPoolHandle.\n       *\n       * @function\n       * @name Evaluator#modReduceTo\n       * @param {CipherText} encrypted CipherText to reduce\n       * @param {ParmsIdType} parmsId Target parmsId to reduce to\n       * @param {CipherText} [destination] CipherText destination to store the\n       * reduced result\n       * @param {MemoryPoolHandle} [pool={@link MemoryPoolHandle.global}]\n       * MemoryPool to use\n       * @returns {CipherText|void} CipherText containing the result or void if\n       * a destination was supplied\n       * @example\n       * const context = seal.Context(encParms, true)\n       * const cipherTextA = seal.CipherText()\n       * // ... after encrypting some data ...\n       * const parmsId = context.lastParmsId\n       * const resultCipher = evaluator.modReduceTo(cipherTextA, parmsId)\n       * // or\n       * const cipherDest = seal.CipherText()\n       * evaluator.modReduceTo(cipherTextA, parmsId, cipherDest)\n       */\n      modReduceTo(\n        encrypted: CipherText,\n        parmsId: ParmsIdType,\n        destination?: CipherText,\n        pool: MemoryPoolHandle = MemoryPoolHandle.global\n      ): CipherText | void {\n        try {\n          if (destination) {\n            _instance.modReduceTo(\n              encrypted.instance,\n              parmsId.instance,\n              destination.instance,\n              pool\n            )\n            return\n          }\n          const temp = CipherText()\n          _instance.modReduceTo(\n            encrypted.instance,\n            parmsId.instance,\n            temp.instance,\n            pool\n          )\n          return temp\n        } catch (e) {\n          throw Exception.safe(e as SealError)\n        }\n      },\n\n      /**\n       * Exponentiates a CipherText. This functions raises encrypted to a power and\n       * stores the result in the destination parameter. Dynamic memory allocations\n       * in the process are allocated from the memory pool pointed to by the given\n       * MemoryPoolHandle. The exponentiation is done in a depth-optimal order, and\n       * relinearization is performed automatically after every multiplication in\n       * the process. In relinearization the given relinearization keys are used.\n       *\n       * @function\n       * @name Evaluator#exponentiate\n       * @param {CipherText} encrypted CipherText to exponentiate\n       * @param {number} exponent Positive integer to exponentiate the CipherText\n       * @param {RelinKeys} relinKeys RelinKeys used to perform relinearization after each exponentiation\n       * @param {CipherText} [destination] CipherText destination to store the exponentiated result\n       * @param {MemoryPoolHandle} [pool={@link MemoryPoolHandle.global}] MemoryPool to use\n       * @returns {CipherText|void} CipherText containing the result or void if a destination was supplied\n       * @example\n       * const relinKeys = keyGenerator.createRelinKeys()\n       * const cipherTextA = seal.CipherText()\n       * // ... after encrypting some data ...\n       * const resultCipher = evaluator.exponentiate(cipherTextA, 3, relinKeys)\n       * // or\n       * const cipherDest = seal.CipherText()\n       * evaluator.exponentiate(cipherTextA, 3, relinKeys, cipherDest)\n       */\n      exponentiate(\n        encrypted: CipherText,\n        exponent: number,\n        relinKeys: RelinKeys,\n        destination?: CipherText,\n        pool: MemoryPoolHandle = MemoryPoolHandle.global\n      ): CipherText | void {\n        try {\n          if (destination) {\n            _instance.exponentiate(\n              encrypted.instance,\n              exponent,\n              relinKeys.instance,\n              destination.instance,\n              pool\n            )\n            return\n          }\n          const temp = CipherText()\n          _instance.exponentiate(\n            encrypted.instance,\n            exponent,\n            relinKeys.instance,\n            temp.instance,\n            pool\n          )\n          return temp\n        } catch (e) {\n          throw Exception.safe(e as SealError)\n        }\n      },\n\n      /**\n       * Adds a CipherText and a PlainText. This function adds a CipherText and\n       * a PlainText and stores the result in the destination parameter. The PlainText\n       * must be valid for the current encryption parameters.\n       *\n       * @function\n       * @name Evaluator#addPlain\n       * @param {CipherText} encrypted CipherText operand A\n       * @param {PlainText} plain PlainText operand B\n       * @param {CipherText} [destination] CipherText destination to store the sum\n       * @param {MemoryPoolHandle} [pool={@link MemoryPoolHandle.global}] MemoryPool to use\n       * @returns {CipherText|void} CipherText containing the result or void if a destination was supplied\n       * @example\n       * const cipherTextA = seal.CipherText()\n       * const plainTextB = seal.PlainText()\n       * // ... after encrypting/encoding some data ...\n       * const resultCipher = evaluator.addPlain(cipherTextA, plainTextB)\n       * // or\n       * const cipherDest = seal.CipherText()\n       * evaluator.addPlain(cipherTextA, plainTextB, cipherDest)\n       */\n      addPlain(\n        encrypted: CipherText,\n        plain: PlainText,\n        destination?: CipherText,\n        pool: MemoryPoolHandle = MemoryPoolHandle.global\n      ): CipherText | void {\n        try {\n          if (destination) {\n            _instance.addPlain(\n              encrypted.instance,\n              plain.instance,\n              destination.instance,\n              pool\n            )\n            return\n          }\n          const temp = CipherText()\n          _instance.addPlain(\n            encrypted.instance,\n            plain.instance,\n            temp.instance,\n            pool\n          )\n          return temp\n        } catch (e) {\n          throw Exception.safe(e as SealError)\n        }\n      },\n\n      /**\n       * Subtracts a PlainText from a CipherText. This function subtracts a PlainText\n       * from a CipherText and stores the result in the destination parameter. The\n       * PlainText must be valid for the current encryption parameters.\n       *\n       * @function\n       * @name Evaluator#subPlain\n       * @param {CipherText} encrypted CipherText operand A\n       * @param {PlainText} plain PlainText operand B\n       * @param {CipherText} [destination] CipherText destination to store the difference\n       * @param {MemoryPoolHandle} [pool={@link MemoryPoolHandle.global}] MemoryPool to use\n       * @returns {CipherText|void} CipherText containing the result or void if a destination was supplied\n       * @example\n       * const cipherTextA = seal.CipherText()\n       * const plainTextB = seal.PlainText()\n       * // ... after encrypting/encoding some data ...\n       * const resultCipher = evaluator.subPlain(cipherTextA, plainTextB)\n       * // or\n       * const cipherDest = seal.CipherText()\n       * evaluator.subPlain(cipherTextA, plainTextB, cipherDest)\n       */\n      subPlain(\n        encrypted: CipherText,\n        plain: PlainText,\n        destination?: CipherText,\n        pool: MemoryPoolHandle = MemoryPoolHandle.global\n      ): CipherText | void {\n        try {\n          if (destination) {\n            _instance.subPlain(\n              encrypted.instance,\n              plain.instance,\n              destination.instance,\n              pool\n            )\n            return\n          }\n          const temp = CipherText()\n          _instance.subPlain(\n            encrypted.instance,\n            plain.instance,\n            temp.instance,\n            pool\n          )\n          return temp\n        } catch (e) {\n          throw Exception.safe(e as SealError)\n        }\n      },\n\n      /**\n       * Multiplies a CipherText with a PlainText. This function multiplies\n       * a CipherText with a PlainText and stores the result in the destination\n       * parameter. The PlainText must be a valid for the current encryption parameters,\n       * and cannot be identially 0. Dynamic memory allocations in the process are\n       * allocated from the memory pool pointed to by the given MemoryPoolHandle.\n       *\n       * @function\n       * @name Evaluator#multiplyPlain\n       * @param {CipherText} encrypted CipherText operand A\n       * @param {PlainText} plain PlainText operand B\n       * @param {CipherText} [destination] CipherText destination to store the product\n       * @param {MemoryPoolHandle} [pool={@link MemoryPoolHandle.global}] MemoryPool to use\n       * @returns {CipherText?} CipherText containing the result or void if a destination was supplied\n       * @example\n       * const cipherTextA = seal.CipherText()\n       * const plainTextB = seal.PlainText()\n       * // ... after encrypting/encoding some data ...\n       * const resultCipher = evaluator.multiplyPlain(cipherTextA, plainTextB)\n       * // or\n       * const cipherDest = seal.CipherText()\n       * evaluator.multiplyPlain(cipherTextA, plainTextB, cipherDest)\n       */\n      multiplyPlain(\n        encrypted: CipherText,\n        plain: PlainText,\n        destination?: CipherText,\n        pool: MemoryPoolHandle = MemoryPoolHandle.global\n      ): CipherText | void {\n        try {\n          if (destination) {\n            _instance.multiplyPlain(\n              encrypted.instance,\n              plain.instance,\n              destination.instance,\n              pool\n            )\n            return\n          }\n          const temp = CipherText()\n          _instance.multiplyPlain(\n            encrypted.instance,\n            plain.instance,\n            temp.instance,\n            pool\n          )\n          return temp\n        } catch (e) {\n          throw Exception.safe(e as SealError)\n        }\n      },\n\n      /**\n       * Transforms a PlainText to NTT domain. This functions applies the number\n       * Theoretic Transform to a PlainText by first embedding integers modulo the\n       * PlainText modulus to integers modulo the coefficient modulus and then\n       * performing David Harvey's NTT on the resulting polynomial. The transformation\n       * is done with respect to encryption parameters corresponding to a given\n       * parmsId. The result is stored in the destinationNtt parameter. For the\n       * operation to be valid, the PlainText must have degree less than PolyModulusDegree\n       * and each coefficient must be less than the PlainText modulus, i.e., the PlainText\n       * must be a valid PlainText under the current encryption parameters. Dynamic\n       * memory allocations in the process are allocated from the memory pool pointed\n       * to by the given MemoryPoolHandle.\n       *\n       * @function\n       * @name Evaluator#plainTransformToNtt\n       * @param {PlainText} plain PlainText to transform\n       * @param {ParmsIdType} parmsId target parmsId to perform NTT transformation\n       * @param {PlainText} [destinationNtt] PlainText destination to store the transformed result\n       * @param {MemoryPoolHandle} [pool={@link MemoryPoolHandle.global}] MemoryPool to use\n       * @returns {PlainText|void} PlainText containing the result or void if a destination was supplied\n       * @example\n       * const context = seal.Context(encParms, true)\n       * const plainTextA = seal.PlainText()\n       * // ... after encoding some data ...\n       * const parmsId = context.lastParmsId\n       * const resultCipher = evaluator.plainTransformToNtt(plainTextA, parmsId)\n       * // or\n       * const plainDest = seal.PlainText()\n       * evaluator.plainTransformToNtt(plainTextA, parmsId, plainDest)\n       */\n      plainTransformToNtt(\n        plain: PlainText,\n        parmsId: ParmsIdType,\n        destinationNtt?: PlainText,\n        pool: MemoryPoolHandle = MemoryPoolHandle.global\n      ): PlainText | void {\n        try {\n          if (destinationNtt) {\n            _instance.plainTransformToNtt(\n              plain.instance,\n              parmsId.instance,\n              destinationNtt.instance,\n              pool\n            )\n            return\n          }\n          const temp = PlainText()\n          _instance.plainTransformToNtt(\n            plain.instance,\n            parmsId.instance,\n            temp.instance,\n            pool\n          )\n          return temp\n        } catch (e) {\n          throw Exception.safe(e as SealError)\n        }\n      },\n\n      /**\n       * Transforms a CipherText to NTT domain. This functions applies David Harvey's\n       * number Theoretic Transform separately to each polynomial of a CipherText.\n       * The result is stored in the destinationNtt parameter.\n       *\n       * @function\n       * @name Evaluator#cipherTransformToNtt\n       * @param {CipherText} encrypted CipherText to transform\n       * @param {CipherText} [destinationNtt] CipherText destination to store the transformed result\n       * @returns {CipherText|void} CipherText containing the result or void if a destination was supplied\n       * @example\n       * const cipherTextA = seal.CipherText()\n       * // ... after encrypting some data ...\n       * const resultCipher = evaluator.cipherTransformToNtt(cipherTextA)\n       * // or\n       * const cipherDest = seal.CipherText()\n       * evaluator.cipherTransformToNtt(cipherTextA, cipherDest)\n       */\n      cipherTransformToNtt(\n        encrypted: CipherText,\n        destinationNtt?: CipherText\n      ): CipherText | void {\n        try {\n          if (destinationNtt) {\n            _instance.cipherTransformToNtt(\n              encrypted.instance,\n              destinationNtt.instance\n            )\n            return\n          }\n          const temp = CipherText()\n          _instance.cipherTransformToNtt(encrypted.instance, temp.instance)\n          return temp\n        } catch (e) {\n          throw Exception.safe(e as SealError)\n        }\n      },\n\n      /**\n       * Transforms a CipherText back from NTT domain. This functions applies the\n       * inverse of David Harvey's number Theoretic Transform separately to each\n       * polynomial of a CipherText. The result is stored in the destination parameter.\n       *\n       * @function\n       * @name Evaluator#cipherTransformFromNtt\n       * @param {CipherText} encryptedNtt CipherText to transform\n       * @param {CipherText} [destination] CipherText destination to store the transformed result\n       * @returns {CipherText|void} CipherText containing the result or void if a destination was supplied\n       * @example\n       * // ... after cipherTransformToNtt ...\n       * const resultCipher = evaluator.cipherTransformFromNtt(cipherTextANtt)\n       * // or\n       * const cipherDest = seal.CipherText()\n       * evaluator.cipherTransformFromNtt(cipherTextANtt, cipherDest)\n       */\n      cipherTransformFromNtt(\n        encryptedNtt: CipherText,\n        destination?: CipherText\n      ): CipherText | void {\n        try {\n          if (destination) {\n            _instance.cipherTransformFromNtt(\n              encryptedNtt.instance,\n              destination.instance\n            )\n            return\n          }\n          const temp = CipherText()\n          _instance.cipherTransformFromNtt(encryptedNtt.instance, temp.instance)\n          return temp\n        } catch (e) {\n          throw Exception.safe(e as SealError)\n        }\n      },\n\n      /**\n       * Applies a Galois automorphism to a CipherText and writes the result to the\n       * destination parameter. To evaluate the Galois automorphism, an appropriate\n       * set of Galois keys must also be provided. Dynamic memory allocations in\n       * the process are allocated from the memory pool pointed to by the given\n       * MemoryPoolHandle.\n       *\n       * The desired Galois automorphism is given as a Galois element, and must be\n       * an odd integer in the interval [1, M-1], where M = 2*N, and N = degree(poly_modulus).\n       * Used with batching, a Galois element 3^i % M corresponds to a cyclic row\n       * rotation i steps to the left, and a Galois element 3^(N/2-i) % M corresponds\n       * to a cyclic row rotation i steps to the right. The Galois element M-1 corresponds\n       * to a column rotation (row swap) in BFV, and complex conjugation in CKKS.\n       * In the polynomial view (not batching), a Galois automorphism by a Galois\n       * element p changes Enc(plain(x)) to Enc(plain(x^p)).\n       *\n       * @function\n       * @name Evaluator#applyGalois\n       * @param {CipherText} encrypted CipherText to apply the automorphism\n       * @param {number} galoisElt number representing the Galois element\n       * @param {GaloisKeys} galoisKeys GaloisKeys used to perform rotations\n       * @param {CipherText} [destination] CipherText destination to store the result\n       * @param {MemoryPoolHandle} [pool={@link MemoryPoolHandle.global}] MemoryPool to use\n       * @returns {CipherText|void} CipherText containing the result or void if a destination was supplied\n       * @example\n       * ...\n       * const evaluator = seal.Evaluator(context)\n       * const arr = Int32Array.from({ length: encoder.slotCount }, (_, i) => i)\n       * const plain = encoder.encode(arr)\n       * const cipher = encryptor.encrypt(plain)\n       * const cipherDest = seal.CipherText()\n       * const galElt = 2 * parms.polyModulusDegree - 1\n       * evaluator.applyGalois(cipher, galElt, galoisKeys, cipherDest)\n       */\n      applyGalois(\n        encrypted: CipherText,\n        galoisElt: number,\n        galoisKeys: GaloisKeys,\n        destination?: CipherText,\n        pool: MemoryPoolHandle = MemoryPoolHandle.global\n      ): CipherText | void {\n        try {\n          if (destination) {\n            _instance.applyGalois(\n              encrypted.instance,\n              galoisElt,\n              galoisKeys.instance,\n              destination.instance,\n              pool\n            )\n            return\n          }\n          const temp = CipherText()\n          _instance.applyGalois(\n            encrypted.instance,\n            galoisElt,\n            galoisKeys.instance,\n            temp.instance,\n            pool\n          )\n          return temp\n        } catch (e) {\n          throw Exception.safe(e as SealError)\n        }\n      },\n\n      /**\n       * Rotates PlainText matrix rows cyclically. When batching is used with the\n       * BFV/BGV scheme, this function rotates the encrypted PlainText matrix rows\n       * cyclically to the left (steps > 0) or to the right (steps < 0) and writes\n       * the result to the destination parameter. Since the size of the batched\n       * matrix is 2-by-(N/2), where N is the degree of the polynomial modulus,\n       * the number of steps to rotate must have absolute value at most N/2-1. Dynamic\n       * memory allocations in the process are allocated from the memory pool pointed\n       * to by the given MemoryPoolHandle.\n       *\n       * @function\n       * @name Evaluator#rotateRows\n       * @param {CipherText} encrypted CipherText to rotate rows\n       * @param {number} steps Int representing steps to rotate (negative = right, positive = left)\n       * @param {GaloisKeys} galoisKeys GaloisKeys used to perform rotations\n       * @param {CipherText} [destination] CipherText destination to store the rotated result\n       * @param {MemoryPoolHandle} [pool={@link MemoryPoolHandle.global}] MemoryPool to use\n       * @returns {CipherText|void} CipherText containing the result or void if a destination was supplied\n       * @example\n       * const galoisKeys = keyGenerator.createGaloisKeys()\n       * const cipherTextA = seal.CipherText()\n       * // ... after encrypting some data ...\n       * const resultCipher = evaluator.rotateRows(cipherTextA, 3, galoisKeys)\n       * // or\n       * const cipherDest = seal.CipherText()\n       * evaluator.rotateRows(cipherTextA, 3, galoisKeys, cipherDest)\n       */\n      rotateRows(\n        encrypted: CipherText,\n        steps: number,\n        galoisKeys: GaloisKeys,\n        destination?: CipherText,\n        pool: MemoryPoolHandle = MemoryPoolHandle.global\n      ): CipherText | void {\n        try {\n          if (destination) {\n            _instance.rotateRows(\n              encrypted.instance,\n              steps,\n              galoisKeys.instance,\n              destination.instance,\n              pool\n            )\n            return\n          }\n          const temp = CipherText()\n          _instance.rotateRows(\n            encrypted.instance,\n            steps,\n            galoisKeys.instance,\n            temp.instance,\n            pool\n          )\n          return temp\n        } catch (e) {\n          throw Exception.safe(e as SealError)\n        }\n      },\n\n      /**\n       * Rotates PlainText matrix columns cyclically. When batching is used with\n       * the BFV scheme, this function rotates the encrypted PlainText matrix columns\n       * cyclically, and writes the result to the destination parameter. Since the\n       * size of the batched matrix is 2-by-(N/2), where N is the degree of the\n       * polynomial modulus, this means simply swapping the two rows. Dynamic memory\n       * allocations in the process are allocated from the memory pool pointed to\n       * by the given MemoryPoolHandle.\n       *\n       * @function\n       * @name Evaluator#rotateColumns\n       * @param {CipherText} encrypted CipherText to rotate columns\n       * @param {GaloisKeys} galoisKeys GaloisKeys used to perform rotations\n       * @param {CipherText} [destination] CipherText destination to store the rotated result\n       * @param {MemoryPoolHandle} [pool={@link MemoryPoolHandle.global}] MemoryPool to use\n       * @returns {CipherText|void} CipherText containing the result or void if a destination was supplied\n       * @example\n       * const galoisKeys = keyGenerator.createGaloisKeys()\n       * const cipherTextA = seal.CipherText()\n       * // ... after encrypting some data ...\n       * const resultCipher = evaluator.rotateColumns(cipherTextA, galoisKeys)\n       * // or\n       * const cipherDest = seal.CipherText()\n       * evaluator.rotateColumns(cipherTextA, galoisKeys, cipherDest)\n       */\n      rotateColumns(\n        encrypted: CipherText,\n        galoisKeys: GaloisKeys,\n        destination?: CipherText,\n        pool: MemoryPoolHandle = MemoryPoolHandle.global\n      ): CipherText | void {\n        try {\n          if (destination) {\n            _instance.rotateColumns(\n              encrypted.instance,\n              galoisKeys.instance,\n              destination.instance,\n              pool\n            )\n            return\n          }\n          const temp = CipherText()\n          _instance.rotateColumns(\n            encrypted.instance,\n            galoisKeys.instance,\n            temp.instance,\n            pool\n          )\n          return temp\n        } catch (e) {\n          throw Exception.safe(e as SealError)\n        }\n      },\n\n      /**\n       * Rotates PlainText vector cyclically. When using the CKKS scheme, this function\n       * rotates the encrypted PlainText vector cyclically to the left (steps > 0)\n       * or to the right (steps < 0) and writes the result to the destination parameter.\n       * Since the size of the batched matrix is 2-by-(N/2), where N is the degree\n       * of the polynomial modulus, the number of steps to rotate must have absolute\n       * value at most N/2-1. Dynamic memory allocations in the process are allocated\n       * from the memory pool pointed to by the given MemoryPoolHandle.\n       *\n       * @function\n       * @name Evaluator#rotateVector\n       * @param {CipherText} encrypted CipherText to rotate the entire vector\n       * @param {number} steps Int representing steps to rotate (negative = right, positive = left)\n       * @param {GaloisKeys} galoisKeys GaloisKeys used to perform rotations\n       * @param {CipherText} [destination] CipherText destination to store the rotated result\n       * @param {MemoryPoolHandle} [pool={@link MemoryPoolHandle.global}] MemoryPool to use\n       * @returns {CipherText|void} CipherText containing the result or void if a destination was supplied\n       * @example\n       * const galoisKeys = keyGenerator.createGaloisKeys()\n       * const cipherTextA = seal.CipherText()\n       * // ... after encrypting some data ...\n       * const resultCipher = evaluator.rotateVector(cipherTextA, 3, galoisKeys)\n       * // or\n       * const cipherDest = seal.CipherText()\n       * evaluator.rotateVector(cipherTextA, 3, galoisKeys, cipherDest)\n       */\n      rotateVector(\n        encrypted: CipherText,\n        steps: number,\n        galoisKeys: GaloisKeys,\n        destination?: CipherText,\n        pool: MemoryPoolHandle = MemoryPoolHandle.global\n      ): CipherText | void {\n        try {\n          if (destination) {\n            _instance.rotateVector(\n              encrypted.instance,\n              steps,\n              galoisKeys.instance,\n              destination.instance,\n              pool\n            )\n            return\n          }\n          const temp = CipherText()\n          _instance.rotateVector(\n            encrypted.instance,\n            steps,\n            galoisKeys.instance,\n            temp.instance,\n            pool\n          )\n          return temp\n        } catch (e) {\n          throw Exception.safe(e as SealError)\n        }\n      },\n\n      /**\n       * Complex conjugates PlainText slot values. When using the CKKS scheme, this\n       * function complex conjugates all values in the underlying PlainText, and\n       * writes the result to the destination parameter. Dynamic memory allocations\n       * in the process are allocated from the memory pool pointed to by the given\n       * MemoryPoolHandle.\n       *\n       * @function\n       * @name Evaluator#complexConjugate\n       * @param {CipherText} encrypted CipherText to complex conjugate\n       * @param {GaloisKeys} galoisKeys GaloisKeys used to perform rotations\n       * @param {CipherText} [destination] CipherText destination to store the conjugated result\n       * @param {MemoryPoolHandle} [pool={@link MemoryPoolHandle.global}] MemoryPool to use\n       * @returns {CipherText|void} CipherText containing the result or void if a destination was supplied\n       * @example\n       * const galoisKeys = keyGenerator.createGaloisKeys()\n       * const cipherTextA = seal.CipherText()\n       * // ... after encrypting some data ...\n       * const resultCipher = evaluator.complexConjugate(cipherTextA, galoisKeys)\n       * // or\n       * const cipherDest = seal.CipherText()\n       * evaluator.complexConjugate(cipherTextA, galoisKeys, cipherDest)\n       */\n      complexConjugate(\n        encrypted: CipherText,\n        galoisKeys: GaloisKeys,\n        destination?: CipherText,\n        pool: MemoryPoolHandle = MemoryPoolHandle.global\n      ): CipherText | void {\n        try {\n          if (destination) {\n            _instance.complexConjugate(\n              encrypted.instance,\n              galoisKeys.instance,\n              destination.instance,\n              pool\n            )\n            return\n          }\n          const temp = CipherText()\n          _instance.complexConjugate(\n            encrypted.instance,\n            galoisKeys.instance,\n            temp.instance,\n            pool\n          )\n          return temp\n        } catch (e) {\n          throw Exception.safe(e as SealError)\n        }\n      },\n\n      /**\n       * Sum all elements in the encrypted CipherText. The resulting CipherText contains the sum in every element.\n       *\n       * @function\n       * @name Evaluator#sumElements\n       * @param {CipherText} encrypted CipherText to sum elements\n       * @param {GaloisKeys} galoisKeys GaloisKeys used to perform rotations\n       * @param {SchemeType} scheme Scheme that was used for encryption\n       * @param {CipherText} [destination] CipherText destination to store the result\n       * @param {MemoryPoolHandle} [pool={@link MemoryPoolHandle.global}] MemoryPool to use\n       * @returns {CipherText|void} CipherText containing the result or void if a destination was supplied\n       * @example\n       * const galoisKeys = keyGenerator.createGaloisKeys()\n       * const cipherTextA = seal.CipherText()\n       * // ... after encrypting some data ...\n       * const resultCipher = evaluator.sumElements(cipherTextA, galoisKeys, seal.SchemeTypes.BFV)\n       * // or\n       * const cipherDest = seal.CipherText()\n       * evaluator.sumElements(cipherTextA, galoisKeys, seal.SchemeTypes.BFV, cipherDest)\n       */\n      sumElements(\n        encrypted: CipherText,\n        galoisKeys: GaloisKeys,\n        scheme: SchemeType,\n        destination?: CipherText,\n        pool: MemoryPoolHandle = MemoryPoolHandle.global\n      ): CipherText | void {\n        try {\n          if (destination) {\n            _instance.sumElements(\n              encrypted.instance,\n              galoisKeys.instance,\n              scheme,\n              destination.instance,\n              pool\n            )\n            return\n          }\n\n          const newDest = CipherText()\n          _instance.sumElements(\n            encrypted.instance,\n            galoisKeys.instance,\n            scheme,\n            newDest.instance,\n            pool\n          )\n          return newDest\n        } catch (e) {\n          throw Exception.safe(e as SealError)\n        }\n      },\n\n      /**\n       * Perform the dot product (A.B) of two CipherTexts The resulting CipherText contains the dot product in every\n       * element.\n       *\n       * @function\n       * @name Evaluator#dotProduct\n       * @param {CipherText} a CipherText operand A\n       * @param {CipherText} b CipherText operand B\n       * @param {RelinKeys} relinKeys RelinKeys used to perform relinearization after multiplication\n       * @param {GaloisKeys} galoisKeys GaloisKeys used to perform rotations\n       * @param {SchemeType} scheme Scheme that was used for encryption\n       * @param {CipherText} [destination] CipherText destination to store the result\n       * @param {MemoryPoolHandle} [pool={@link MemoryPoolHandle.global}] MemoryPool to use\n       * @returns {CipherText|void} CipherText containing the result or void if a destination was supplied\n       * @example\n       * const relinKeys = keyGenerator.createRelinKeys()\n       * const galoisKeys = keyGenerator.createGaloisKeys()\n       * const cipherTextA = seal.CipherText()\n       * const cipherTextB = seal.CipherText()\n       * // ... after encrypting some data ...\n       * const resultCipher = evaluator.dotProduct(cipherTextA, cipherTextB, relinKeys, galoisKeys, seal.SchemeTypes.BFV)\n       * // or\n       * const cipherDest = seal.CipherText()\n       * evaluator.dotProduct(cipherTextA, cipherTextB, relinKeys, galoisKeys, seal.SchemeTypes.BFV, cipherDest)\n       */\n      dotProduct(\n        a: CipherText,\n        b: CipherText,\n        relinKeys: RelinKeys,\n        galoisKeys: GaloisKeys,\n        scheme: SchemeType,\n        destination?: CipherText,\n        pool: MemoryPoolHandle = MemoryPoolHandle.global\n      ): CipherText | void {\n        try {\n          if (destination) {\n            _instance.multiply(\n              a.instance,\n              b.instance,\n              destination.instance,\n              pool\n            )\n            _instance.relinearize(\n              destination.instance,\n              relinKeys.instance,\n              destination.instance,\n              pool\n            )\n            _instance.sumElements(\n              destination.instance,\n              galoisKeys.instance,\n              scheme,\n              destination.instance,\n              pool\n            )\n            return\n          }\n\n          const newDest = CipherText()\n          _instance.multiply(a.instance, b.instance, newDest.instance, pool)\n          _instance.relinearize(\n            newDest.instance,\n            relinKeys.instance,\n            newDest.instance,\n            pool\n          )\n          _instance.sumElements(\n            newDest.instance,\n            galoisKeys.instance,\n            scheme,\n            newDest.instance,\n            pool\n          )\n          return newDest\n        } catch (e) {\n          throw Exception.safe(e as SealError)\n        }\n      },\n\n      /**\n       * Perform the dot product (A.B) of CipherText (A) and PlainText (B). The resulting CipherText contains the dot\n       * product in every element.\n       *\n       * @function\n       * @name Evaluator#dotProductPlain\n       * @param {CipherText} a CipherText operand A\n       * @param {PlainText} b PlainText operand B\n       * @param {GaloisKeys} galoisKeys GaloisKeys used to perform rotations\n       * @param {SchemeType} scheme Scheme that was used for encryption\n       * @param {CipherText} [destination] CipherText destination to store the result\n       * @param {MemoryPoolHandle} [pool={@link MemoryPoolHandle.global}] MemoryPool to use\n       * @returns {CipherText|void} CipherText containing the result or void if a destination was supplied\n       * @example\n       * const galoisKeys = keyGenerator.createGaloisKeys()\n       * const cipherTextA = seal.CipherText()\n       * const plainTextB = seal.PlainText()\n       * // ... after encoding / encrypting some data ...\n       * const resultCipher = evaluator.dotProductPlain(cipherTextA, plainTextB, galoisKeys, seal.SchemeTypes.BFV)\n       * // or\n       * const cipherDest = seal.CipherText()\n       * evaluator.dotProductPlain(cipherTextA, plainTextB, galoisKeys, seal.SchemeTypes.BFV, cipherDest)\n       */\n      dotProductPlain(\n        a: CipherText,\n        b: PlainText,\n        galoisKeys: GaloisKeys,\n        scheme: SchemeType,\n        destination?: CipherText,\n        pool: MemoryPoolHandle = MemoryPoolHandle.global\n      ): CipherText | void {\n        try {\n          if (destination) {\n            _instance.multiplyPlain(\n              a.instance,\n              b.instance,\n              destination.instance,\n              pool\n            )\n            _instance.sumElements(\n              destination.instance,\n              galoisKeys.instance,\n              scheme,\n              destination.instance,\n              pool\n            )\n            return\n          }\n\n          const newDest = CipherText()\n          _instance.multiplyPlain(\n            a.instance,\n            b.instance,\n            newDest.instance,\n            pool\n          )\n          _instance.sumElements(\n            newDest.instance,\n            galoisKeys.instance,\n            scheme,\n            newDest.instance,\n            pool\n          )\n          return newDest\n        } catch (e) {\n          throw Exception.safe(e as SealError)\n        }\n      }\n    }\n  }\n\nexport const EvaluatorInit = ({\n  loader\n}: LoaderOptions): EvaluatorDependencies => {\n  const library: Library = loader.library\n  return EvaluatorConstructor(library)\n}\n","import { Library, LoaderOptions } from './seal'\n\nexport type ExceptionDependencies = {\n  (): ExceptionConstructorOptions\n}\n\nexport type ExceptionConstructorOptions = {\n  (): Exception\n}\n\nexport type SealError = number | Error | string\n\nexport type Exception = {\n  readonly safe: (e: SealError) => Error\n}\n\nconst ExceptionConstructor =\n  (library: Library): ExceptionDependencies =>\n  (): ExceptionConstructorOptions =>\n  (): Exception => {\n    // Static methods\n    const _getException = library.getException\n\n    /**\n     * @implements Exception\n     */\n\n    /**\n     * @interface Exception\n     */\n    return {\n      /**\n       * Takes a caught exception in SEAL library and gets a safe error string\n       *\n       * @function\n       * @name Exception.safe\n       * @param {(number|Error|string)} error Unsafe error to normalize\n       * @returns {Error}\n       */\n      safe(error: number | Error | string): Error {\n        if (typeof error === 'number') {\n          return new Error(_getException(error))\n        }\n\n        if (error instanceof Error) {\n          return error\n        }\n        return new Error(error || 'Unknown Error!')\n      }\n    }\n  }\n\nexport const ExceptionInit = ({\n  loader\n}: LoaderOptions): ExceptionDependencies => {\n  const library: Library = loader.library\n  return ExceptionConstructor(library)\n}\n","import { ComprModeType } from './compr-mode-type'\nimport { Context } from './context'\nimport { Exception, SealError } from './exception'\nimport { Instance, Library, LoaderOptions } from './seal'\nimport { VectorConstructorOptions } from './vector'\n\nexport type GaloisKeysDependencyOptions = {\n  readonly Exception: Exception\n  readonly ComprModeType: ComprModeType\n  readonly Vector: VectorConstructorOptions\n}\n\nexport type GaloisKeysDependencies = {\n  ({\n    Exception,\n    ComprModeType,\n    Vector\n  }: GaloisKeysDependencyOptions): GaloisKeysConstructorOptions\n}\n\nexport type GaloisKeysConstructorOptions = {\n  (): GaloisKeys\n}\n\nexport type GaloisKeys = {\n  readonly instance: Instance\n  readonly inject: (instance: Instance) => void\n  readonly delete: () => void\n  readonly size: number\n  readonly getIndex: (galoisElt: number) => number\n  readonly hasKey: (galoisElt: number) => boolean\n  readonly save: (compression?: ComprModeType) => string\n  readonly saveArray: (compression?: ComprModeType) => Uint8Array\n  readonly load: (context: Context, encoded: string) => void\n  readonly loadArray: (context: Context, array: Uint8Array) => void\n  readonly copy: (key: GaloisKeys) => void\n  readonly clone: () => GaloisKeys\n  readonly move: (key: GaloisKeys) => void\n}\n\nconst GaloisKeysConstructor =\n  (library: Library): GaloisKeysDependencies =>\n  ({\n    Exception,\n    ComprModeType,\n    Vector\n  }: GaloisKeysDependencyOptions): GaloisKeysConstructorOptions =>\n  (): GaloisKeys => {\n    const Constructor = library.GaloisKeys\n    let _instance = new Constructor()\n\n    /**\n     * @implements GaloisKeys\n     */\n\n    /**\n     * @interface GaloisKeys\n     */\n    return {\n      /**\n       * Get the underlying WASM instance\n       *\n       * @private\n       * @readonly\n       * @name GaloisKeys#instance\n       * @type {Instance}\n       */\n      get instance() {\n        return _instance\n      },\n\n      /**\n       * Inject this object with a raw WASM instance\n       *\n       * @private\n       * @function\n       * @name GaloisKeys#inject\n       * @param {Instance} instance WASM instance\n       */\n      inject(instance: Instance) {\n        if (_instance) {\n          _instance.delete()\n          _instance = undefined\n        }\n        _instance = new Constructor(instance)\n        instance.delete()\n      },\n\n      /**\n       * Delete the underlying WASM instance.\n       *\n       * Should be called before dereferencing this object to prevent the\n       * WASM heap from growing indefinitely.\n       * @function\n       * @name GaloisKeys#delete\n       */\n      delete() {\n        if (_instance) {\n          _instance.delete()\n          _instance = undefined\n        }\n      },\n\n      /**\n       * Returns the current number of keyswitching keys. Only keys that are\n       * non-empty are counted.\n       *\n       * @readonly\n       * @name GaloisKeys#size\n       * @type {number}\n       */\n      get size() {\n        return _instance.size()\n      },\n\n      /**\n       * Returns the index of a Galois key in the backing KSwitchKeys instance that\n       * corresponds to the given Galois element, assuming that it exists in the\n       * backing KSwitchKeys.\n       *\n       * @function\n       * @name GaloisKeys#getIndex\n       * @param {number} galoisElt The Galois element\n       * @returns {number} The index of the galois element\n       */\n      getIndex(galoisElt: number): number {\n        try {\n          return _instance.getIndex(galoisElt)\n        } catch (e) {\n          throw Exception.safe(e as SealError)\n        }\n      },\n\n      /**\n       * Returns whether a Galois key corresponding to a given Galois element exists.\n       *\n       * @function\n       * @name GaloisKeys#hasKey\n       * @param {number} galoisElt The Galois element\n       * @returns {boolean} True if the key exists\n       */\n      hasKey(galoisElt: number): boolean {\n        try {\n          return _instance.hasKey(galoisElt)\n        } catch (e) {\n          throw Exception.safe(e as SealError)\n        }\n      },\n      /**\n       * Save the Encryption Parameters to a base64 string\n       *\n       * @function\n       * @name GaloisKeys#save\n       * @param {ComprModeType} [compression={@link ComprModeType.zstd}] The compression mode to use\n       * @returns {string} Base64 encoded string\n       */\n      save(compression: ComprModeType = ComprModeType.zstd): string {\n        try {\n          return _instance.saveToString(compression)\n        } catch (e) {\n          throw Exception.safe(e as SealError)\n        }\n      },\n\n      /**\n       * Save the GaloisKeys as a binary Uint8Array\n       *\n       * @function\n       * @name GaloisKeys#saveArray\n       * @param {ComprModeType} [compression={@link ComprModeType.zstd}] The compression mode to use\n       * @returns {Uint8Array} A byte array containing the GaloisKeys in binary form\n       */\n      saveArray(compression: ComprModeType = ComprModeType.zstd): Uint8Array {\n        const tempVect = Vector()\n        const instance = _instance.saveToArray(compression)\n        tempVect.unsafeInject(instance)\n        tempVect.setType('Uint8Array')\n        const tempArr = tempVect.toArray() as Uint8Array\n        tempVect.delete()\n        return tempArr\n      },\n\n      /**\n       * Load a GaloisKeys from a base64 string\n       *\n       * @function\n       * @name GaloisKeys#load\n       * @param {Context} context Encryption context to enforce\n       * @param {string} encoded Base64 encoded string\n       */\n      load(context: Context, encoded: string) {\n        try {\n          _instance.loadFromString(context.instance, encoded)\n        } catch (e) {\n          throw Exception.safe(e as SealError)\n        }\n      },\n\n      /**\n       * Load a GaloisKeys from an Uint8Array holding binary data\n       *\n       * @function\n       * @name GaloisKeys#loadArray\n       * @param {Context} context Encryption context to enforce\n       * @param {Uint8Array} array TypedArray containing binary data\n       */\n      loadArray(context: Context, array: Uint8Array) {\n        try {\n          _instance.loadFromArray(context.instance, array)\n        } catch (e) {\n          throw Exception.safe(e as SealError)\n        }\n      },\n\n      /**\n       * Copy an existing GaloisKeys and overwrite this instance\n       *\n       * @function\n       * @name GaloisKeys#copy\n       * @param {GaloisKeys} key GaloisKeys to copy\n       * @example\n       * const keyA = keyGenerator.createGaloisKeys()\n       * const keyB = seal.GaloisKeys()\n       * keyB.copy(keyA)\n       * // keyB holds a copy of keyA\n       */\n      copy(key: GaloisKeys) {\n        try {\n          _instance.copy(key.instance)\n        } catch (e) {\n          throw Exception.safe(e as SealError)\n        }\n      },\n\n      /**\n       * Clone and return a new instance of this GaloisKeys\n       *\n       * @function\n       * @name GaloisKeys#clone\n       * @returns {GaloisKeys}\n       * @example\n       * const keyA = keyGenerator.createGaloisKeys()\n       * const keyB = keyA.clone()\n       * // keyB holds a copy of keyA\n       */\n      clone(): GaloisKeys {\n        try {\n          const clonedInstance = _instance.clone()\n          const key = GaloisKeysConstructor(library)({\n            Exception,\n            ComprModeType,\n            Vector\n          })()\n          key.inject(clonedInstance)\n          return key\n        } catch (e) {\n          throw Exception.safe(e as SealError)\n        }\n      },\n\n      /**\n       * Move a GaloisKeys into this one and delete the old reference\n       *\n       * @function\n       * @name GaloisKeys#move\n       * @param {GaloisKeys} key GaloisKeys to move\n       * @example\n       * const keyA = keyGenerator.createGaloisKeys()\n       * const keyB = seal.GaloisKeys()\n       * keyB.move(keyA)\n       * // keyB holds a the instance of keyA.\n       * // keyA no longer holds an instance\n       */\n      move(key: GaloisKeys) {\n        try {\n          _instance.move(key.instance)\n          // TODO: find optimization\n          // This method results in a copy instead of a real move.\n          // Therefore, we need to delete the old instance.\n          key.delete()\n        } catch (e) {\n          throw Exception.safe(e as SealError)\n        }\n      }\n    }\n  }\n\nexport const GaloisKeysInit = ({\n  loader\n}: LoaderOptions): GaloisKeysDependencies => {\n  const library: Library = loader.library\n  return GaloisKeysConstructor(library)\n}\n","import { Context } from './context'\nimport { Exception, SealError } from './exception'\nimport { GaloisKeys, GaloisKeysConstructorOptions } from './galois-keys'\nimport { PublicKey, PublicKeyConstructorOptions } from './public-key'\nimport { RelinKeys, RelinKeysConstructorOptions } from './relin-keys'\nimport { Instance, Library, LoaderOptions } from './seal'\nimport { SecretKey, SecretKeyConstructorOptions } from './secret-key'\nimport { Serializable, SerializableConstructorOptions } from './serializable'\n\nexport type KeyGeneratorDependencyOptions = {\n  readonly Exception: Exception\n  readonly PublicKey: PublicKeyConstructorOptions\n  readonly SecretKey: SecretKeyConstructorOptions\n  readonly RelinKeys: RelinKeysConstructorOptions\n  readonly GaloisKeys: GaloisKeysConstructorOptions\n  readonly Serializable: SerializableConstructorOptions\n}\n\nexport type KeyGeneratorDependencies = {\n  ({\n    Exception,\n    PublicKey,\n    SecretKey,\n    RelinKeys,\n    GaloisKeys,\n    Serializable\n  }: KeyGeneratorDependencyOptions): KeyGeneratorConstructorOptions\n}\n\nexport type KeyGeneratorConstructorOptions = {\n  (context: Context, secretKey?: SecretKey): KeyGenerator\n}\n\nexport type KeyGenerator = {\n  readonly instance: Instance\n  readonly unsafeInject: (instance: Instance) => void\n  readonly delete: () => void\n  readonly secretKey: () => SecretKey\n  readonly createPublicKeySerializable: () => Serializable\n  readonly createPublicKey: () => PublicKey\n  readonly createRelinKeysSerializable: () => Serializable\n  readonly createRelinKeys: () => RelinKeys\n  readonly createGaloisKeysSerializable: (steps?: Int32Array) => Serializable\n  readonly createGaloisKeys: (steps?: Int32Array) => GaloisKeys\n}\n\nconst KeyGeneratorConstructor =\n  (library: Library): KeyGeneratorDependencies =>\n  ({\n    Exception,\n    PublicKey,\n    SecretKey,\n    RelinKeys,\n    GaloisKeys,\n    Serializable\n  }: KeyGeneratorDependencyOptions): KeyGeneratorConstructorOptions =>\n  (context, secretKey): KeyGenerator => {\n    const Constructor = library.KeyGenerator\n    let _instance = constructInstance(context, secretKey)\n\n    function constructInstance(context: Context, secretKey?: SecretKey) {\n      try {\n        if (secretKey) {\n          return new Constructor(context.instance, secretKey.instance)\n        }\n        return new Constructor(context.instance)\n      } catch (e) {\n        throw Exception.safe(e as SealError)\n      }\n    }\n    /**\n     * @implements KeyGenerator\n     */\n\n    /**\n     * @interface KeyGenerator\n     */\n    return {\n      /**\n       * Get the underlying WASM instance\n       *\n       * @private\n       * @readonly\n       * @name KeyGenerator#instance\n       * @type {Instance}\n       */\n      get instance() {\n        return _instance\n      },\n\n      /**\n       * Inject this object with a raw WASM instance. No type checking is performed.\n       *\n       * @private\n       * @function\n       * @name KeyGenerator#unsafeInject\n       * @param {Instance} instance WASM instance\n       */\n      unsafeInject(instance: Instance) {\n        if (_instance) {\n          _instance.delete()\n          _instance = undefined\n        }\n        _instance = instance\n      },\n\n      /**\n       * Delete the underlying WASM instance.\n       *\n       * Should be called before dereferencing this object to prevent the\n       * WASM heap from growing indefinitely.\n       * @function\n       * @name KeyGenerator#delete\n       */\n      delete() {\n        if (_instance) {\n          _instance.delete()\n          _instance = undefined\n        }\n      },\n\n      /**\n       * Return the generated SecretKey\n       *\n       * @function\n       * @name KeyGenerator#secretKey\n       * @returns {SecretKey} The secret key that was generated upon instantiation of this KeyGenerator\n       */\n      secretKey(): SecretKey {\n        try {\n          const key = SecretKey()\n          const instance = _instance.secretKey()\n          key.inject(instance)\n          return key\n        } catch (e) {\n          throw Exception.safe(e as SealError)\n        }\n      },\n\n      /**\n       * Create a new PublicKey instance\n       *\n       * @function\n       * @name KeyGenerator#createPublicKey\n       * @returns {PublicKey} A new PublicKey instance\n       */\n      createPublicKey(): PublicKey {\n        try {\n          const key = PublicKey()\n          _instance.createPublicKey(key.instance)\n          return key\n        } catch (e) {\n          throw Exception.safe(e as SealError)\n        }\n      },\n\n      /**\n       * Create a new, Serializable PublicKey instance\n       *\n       * @function\n       * @name KeyGenerator#createPublicKeySerializable\n       * @returns {Serializable<PublicKey>} A new, serializable, PublicKey instance\n       */\n      createPublicKeySerializable(): Serializable {\n        try {\n          const serialized = Serializable()\n          const instance = _instance.createPublicKeySerializable()\n          serialized.unsafeInject(instance)\n          return serialized\n        } catch (e) {\n          throw Exception.safe(e as SealError)\n        }\n      },\n\n      /**\n       * Generates and returns relinearization keys. This function returns\n       * relinearization keys in a fully expanded form and is meant to be used\n       * primarily for demo, testing, and debugging purposes.\n       *\n       * @function\n       * @name KeyGenerator#createRelinKeys\n       * @returns {RelinKeys} New RelinKeys from the KeyGenerator's internal secret key\n       */\n      createRelinKeys(): RelinKeys {\n        try {\n          const keys = RelinKeys()\n          _instance.createRelinKeys(keys.instance)\n          return keys\n        } catch (e) {\n          throw Exception.safe(e as SealError)\n        }\n      },\n\n      /**\n       * Generates and returns relinearization keys as a serializable object.\n       *\n       * Half of the key data is pseudo-randomly generated from a seed to reduce\n       * the object size. The resulting serializable object cannot be used\n       * directly and is meant to be serialized for the size reduction to have an\n       * impact.\n       *\n       *\n       * @function\n       * @name KeyGenerator#createRelinKeysSerializable\n       * @returns {Serializable<RelinKeys>} New, serializable RelinKeys from the KeyGenerator's internal secret key\n       */\n      createRelinKeysSerializable(): Serializable {\n        try {\n          const serialized = Serializable()\n          const instance = _instance.createRelinKeysSerializable()\n          serialized.unsafeInject(instance)\n          return serialized\n        } catch (e) {\n          throw Exception.safe(e as SealError)\n        }\n      },\n\n      /**\n       * Generates and returns Galois keys. This function returns Galois keys in\n       * a fully expanded form and is meant to be used primarily for demo, testing,\n       * and debugging purposes. The user can optionally give an input a vector of desired\n       * Galois rotation step counts, where negative step counts correspond to\n       * rotations to the right and positive step counts correspond to rotations to\n       * the left. A step count of zero can be used to indicate a column rotation\n       * in the BFV scheme complex conjugation in the CKKS scheme.\n       *\n       * @function\n       * @name KeyGenerator#createGaloisKeys\n       * @param {Int32Array} [steps=Int32Array.from([])] Specific Galois Elements to generate\n       * @returns {GaloisKeys} New GaloisKeys from the KeyGenerator's internal secret key\n       */\n      createGaloisKeys(steps: Int32Array = Int32Array.from([])): GaloisKeys {\n        try {\n          const keys = GaloisKeys()\n          _instance.createGaloisKeys(steps, keys.instance)\n          return keys\n        } catch (e) {\n          throw Exception.safe(e as SealError)\n        }\n      },\n\n      /**\n       * Generates and returns Galois keys as a serializable object. This function\n       * creates specific Galois keys that can be used to apply specific Galois\n       * automorphisms on encrypted data. The user can optionally give an input a vector\n       * of desired Galois rotation step counts, where negative step counts\n       * correspond to rotations to the right and positive step counts correspond\n       * to rotations to the left. A step count of zero can be used to indicate\n       * a column rotation in the BFV scheme complex conjugation in the CKKS scheme.\n       * Half of the key data is pseudo-randomly generated from a seed to reduce\n       * the object size. The resulting serializable object cannot be used\n       * directly and is meant to be serialized for the size reduction to have an\n       * impact.\n       *\n       * @function\n       * @name KeyGenerator#createGaloisKeysSerializable\n       * @param {Int32Array} [steps=Int32Array.from([])] Specific Galois Elements to generate\n       * @returns {Serializable<GaloisKeys>} Base64 encoded string\n       */\n      createGaloisKeysSerializable(\n        steps: Int32Array = Int32Array.from([])\n      ): Serializable {\n        try {\n          const serialized = Serializable()\n          const instance = _instance.createGaloisKeysSerializable(steps)\n          serialized.unsafeInject(instance)\n          return serialized\n        } catch (e) {\n          throw Exception.safe(e as SealError)\n        }\n      }\n    }\n  }\n\nexport const KeyGeneratorInit = ({\n  loader\n}: LoaderOptions): KeyGeneratorDependencies => {\n  const library: Library = loader.library\n  return KeyGeneratorConstructor(library)\n}\n","import { Library, LoaderOptions } from './seal'\n\nexport type MemoryPoolHandleDependencies = {\n  (): MemoryPoolHandleConstructorOptions\n}\n\nexport type MemoryPoolHandleConstructorOptions = {\n  (): MemoryPoolHandle\n}\n\nexport type MemoryPoolHandle = {\n  readonly global: any\n  readonly threadLocal: any\n}\n\nconst MemoryPoolHandleConstructor =\n  (library: Library): MemoryPoolHandleDependencies =>\n  (): MemoryPoolHandleConstructorOptions =>\n  (): MemoryPoolHandle => {\n    // Static methods\n    const _global = library.MemoryPoolHandle.MemoryPoolHandleGlobal\n    const _threadLocal = library.MemoryPoolHandle.MemoryPoolHandleThreadLocal\n\n    /**\n     * @implements MemoryPoolHandle\n     */\n\n    /**\n     * @interface MemoryPoolHandle\n     */\n    return {\n      /**\n       * The MemoryPoolHandle pointing to the global memory pool.\n       *\n       * @readonly\n       * @name MemoryPoolHandle.global\n       * @type {MemoryPoolHandle.global}\n       */\n      get global() {\n        /**\n         * @typedef {MemoryPoolHandle.global} MemoryPoolHandle.global\n         */\n        return _global()\n      },\n\n      /**\n       * The MemoryPoolHandle pointing to the thread-local memory pool.\n       *\n       * @readonly\n       * @name MemoryPoolHandle.threadLocal\n       * @type {MemoryPoolHandle.threadLocal}\n       */\n      get threadLocal() {\n        /**\n         * @typedef {MemoryPoolHandle.threadLocal} MemoryPoolHandle.threadLocal\n         */\n        return _threadLocal()\n      }\n    }\n  }\n\nexport const MemoryPoolHandleInit = ({\n  loader\n}: LoaderOptions): MemoryPoolHandleDependencies => {\n  const library: Library = loader.library\n  return MemoryPoolHandleConstructor(library)\n}\n","import { ComprModeType } from './compr-mode-type'\nimport { Exception, SealError } from './exception'\nimport { Instance, Library, LoaderOptions } from './seal'\nimport { VectorConstructorOptions } from './vector'\n\nexport type ModulusDependencyOptions = {\n  readonly Exception: Exception\n  readonly ComprModeType: ComprModeType\n  readonly Vector: VectorConstructorOptions\n}\n\nexport type ModulusDependencies = {\n  ({\n    Exception,\n    ComprModeType,\n    Vector\n  }: ModulusDependencyOptions): ModulusConstructorOptions\n}\n\nexport type ModulusConstructorOptions = {\n  (value: bigint): Modulus\n}\n\nexport type Modulus = {\n  readonly instance: Instance\n  readonly inject: (instance: Instance) => void\n  readonly delete: () => void\n  readonly setValue: (value: bigint) => void\n  readonly value: bigint\n  readonly bitCount: number\n  readonly isZero: boolean\n  readonly isPrime: boolean\n  readonly save: (compression?: ComprModeType) => string\n  readonly saveArray: (compression?: ComprModeType) => Uint8Array\n  readonly load: (encoded: string) => void\n  readonly loadArray: (array: Uint8Array) => void\n}\n\nconst ModulusConstructor =\n  (library: Library): ModulusDependencies =>\n  ({\n    Exception,\n    ComprModeType,\n    Vector\n  }: ModulusDependencyOptions): ModulusConstructorOptions =>\n  (value: bigint): Modulus => {\n    // Static methods\n    const Constructor = library.Modulus\n\n    let _instance = createModulus(value)\n\n    function createModulus(value: bigint) {\n      try {\n        const inst = new Constructor()\n        inst.setValue(value.toString())\n        return inst\n      } catch (e) {\n        throw Exception.safe(e as SealError)\n      }\n    }\n\n    /**\n     * @implements Modulus\n     */\n\n    /**\n     * @interface Modulus\n     */\n    return {\n      /**\n       * Get the underlying WASM instance\n       *\n       * @private\n       * @readonly\n       * @name Modulus#instance\n       * @type {Instance}\n       */\n      get instance() {\n        return _instance\n      },\n\n      /**\n       * Inject this object with a raw WASM instance\n       *\n       * @private\n       * @function\n       * @name Modulus#inject\n       * @param {Instance} instance WASM instance\n       */\n      inject(instance: Instance) {\n        if (_instance) {\n          _instance.delete()\n          _instance = undefined\n        }\n        _instance = new Constructor(instance)\n        instance.delete()\n      },\n\n      /**\n       * Delete the underlying WASM instance.\n       *\n       * Should be called before dereferencing this object to prevent the\n       * WASM heap from growing indefinitely.\n       * @function\n       * @name Modulus#delete\n       */\n      delete() {\n        if (_instance) {\n          _instance.delete()\n          _instance = undefined\n        }\n      },\n\n      /**\n       * Loads a Modulus from a string representing an uint64 value.\n       *\n       * @function\n       * @name Modulus#setValue\n       * @param {BigInt} value BigInt value to set\n       */\n      setValue(value: bigint) {\n        try {\n          _instance.setValue(value.toString())\n        } catch (e) {\n          throw Exception.safe(e as SealError)\n        }\n      },\n\n      /**\n       * The value of the current Modulus as a BigInt.\n       *\n       * @readonly\n       * @name Modulus#value\n       * @type {BigInt}\n       */\n      get value() {\n        // eslint-disable-next-line no-undef\n        return BigInt(_instance.value())\n      },\n\n      /**\n       * The significant bit count of the value of the current Modulus.\n       *\n       * @readonly\n       * @name Modulus#bitCount\n       * @type {number}\n       */\n      get bitCount() {\n        return _instance.bitCount()\n      },\n\n      /**\n       * Whether the value of the current Modulus is zero.\n       *\n       * @readonly\n       * @name Modulus#isZero\n       * @type {boolean}\n       */\n      get isZero() {\n        return _instance.isZero()\n      },\n\n      /**\n       * Whether the value of the current Modulus is a prime number.\n       *\n       * @readonly\n       * @name Modulus#isPrime\n       * @type {boolean}\n       */\n      get isPrime() {\n        return _instance.isPrime()\n      },\n\n      /**\n       * Save the Modulus as a base64 string\n       *\n       * @function\n       * @name Modulus#save\n       * @param {ComprModeType} [compression={@link ComprModeType.zstd}] The compression mode to use\n       * @returns {string} Base64 encoded string\n       */\n      save(compression: ComprModeType = ComprModeType.zstd): string {\n        return _instance.saveToString(compression)\n      },\n\n      /**\n       * Save the Modulus as a binary Uint8Array\n       *\n       * @function\n       * @name Modulus#saveArray\n       * @param {ComprModeType} [compression={@link ComprModeType.zstd}] The compression mode to use\n       * @returns {Uint8Array} A byte array containing the Modulus in binary form\n       */\n      saveArray(compression: ComprModeType = ComprModeType.zstd): Uint8Array {\n        const tempVect = Vector()\n        const instance = _instance.saveToArray(compression)\n        tempVect.unsafeInject(instance)\n        tempVect.setType('Uint8Array')\n        const tempArr = tempVect.toArray() as Uint8Array\n        tempVect.delete()\n        return tempArr\n      },\n\n      /**\n       * Load a Modulus from a base64 string\n       *\n       * @function\n       * @name Modulus#load\n       * @param {string} encoded Base64 encoded string\n       */\n      load(encoded: string) {\n        try {\n          _instance.loadFromString(encoded)\n        } catch (e) {\n          throw Exception.safe(e as SealError)\n        }\n      },\n\n      /**\n       * Load a Modulus from an Uint8Array holding binary data\n       *\n       * @function\n       * @name Modulus#loadArray\n       * @param {Uint8Array} array TypedArray containing binary data\n       */\n      loadArray(array: Uint8Array) {\n        try {\n          _instance.loadFromArray(array)\n        } catch (e) {\n          throw Exception.safe(e as SealError)\n        }\n      }\n    }\n  }\n\nexport const ModulusInit = ({ loader }: LoaderOptions): ModulusDependencies => {\n  const library: Library = loader.library\n  return ModulusConstructor(library)\n}\n","import { Exception, SealError } from './exception'\nimport { Instance, Library, LoaderOptions } from './seal'\n\nexport type ParmsIdTypeDependencyOptions = {\n  readonly Exception: Exception\n}\n\nexport type ParmsIdTypeDependencies = {\n  ({ Exception }: ParmsIdTypeDependencyOptions): ParmsIdTypeConstructorOptions\n}\n\nexport type ParmsIdTypeConstructorOptions = {\n  (): ParmsIdType\n}\n\nexport type ParmsIdType = {\n  readonly instance: Instance\n  readonly inject: (instance: Instance) => void\n  readonly delete: () => void\n  readonly values: BigUint64Array\n}\n\nconst ParmsIdTypeConstructor =\n  (library: Library): ParmsIdTypeDependencies =>\n  ({\n    Exception\n  }: ParmsIdTypeDependencyOptions): ParmsIdTypeConstructorOptions =>\n  (): ParmsIdType => {\n    const Constructor = library.ParmsIdType\n\n    let _instance: Instance\n\n    /**\n     * @implements ParmsIdType\n     */\n\n    /**\n     * @interface ParmsIdType\n     */\n    return {\n      /**\n       * Get the underlying WASM instance\n       *\n       * @private\n       * @readonly\n       * @name ParmsIdType#instance\n       * @type {Instance}\n       */\n      get instance() {\n        return _instance\n      },\n\n      /**\n       * Inject this object with a raw WASM instance\n       *\n       * @private\n       * @function\n       * @name ParmsIdType#inject\n       * @param {Instance} instance WASM instance\n       */\n      inject(instance: Instance) {\n        if (_instance) {\n          _instance.delete()\n          _instance = undefined\n        }\n        _instance = new Constructor(instance)\n        instance.delete()\n      },\n\n      /**\n       * Delete the underlying WASM instance.\n       *\n       * Should be called before dereferencing this object to prevent the\n       * WASM heap from growing indefinitely.\n       * @function\n       * @name ParmsIdType#delete\n       */\n      delete() {\n        if (_instance) {\n          _instance.delete()\n          _instance = undefined\n        }\n      },\n\n      /**\n       * The values of the current ParmsIdType as an Array of BigInts.\n       *\n       * @readonly\n       * @name ParmsIdType#values\n       * @type {BigUint64Array}\n       */\n      get values() {\n        try {\n          const instance = _instance.values()\n          return BigUint64Array.from(instance)\n        } catch (e) {\n          throw Exception.safe(e as SealError)\n        }\n      }\n    }\n  }\n\nexport const ParmsIdTypeInit = ({\n  loader\n}: LoaderOptions): ParmsIdTypeDependencies => {\n  const library: Library = loader.library\n  return ParmsIdTypeConstructor(library)\n}\n","import { Exception, SealError } from './exception'\nimport { Modulus, ModulusConstructorOptions } from './modulus'\nimport { Library, LoaderOptions } from './seal'\nimport { Vector, VectorConstructorOptions } from './vector'\n\nexport type PlainModulusDependencyOptions = {\n  readonly Exception: Exception\n  readonly Modulus: ModulusConstructorOptions\n  readonly Vector: VectorConstructorOptions\n}\n\nexport type PlainModulusDependencies = {\n  ({\n    Exception,\n    Modulus,\n    Vector\n  }: PlainModulusDependencyOptions): PlainModulusConstructorOptions\n}\n\nexport type PlainModulusConstructorOptions = {\n  (): PlainModulus\n}\n\nexport type PlainModulus = {\n  readonly Batching: (polyModulusDegree: number, bitSize: number) => Modulus\n  readonly BatchingVector: (\n    polyModulusDegree: number,\n    bitSizes: Int32Array\n  ) => Vector\n}\n\nconst PlainModulusConstructor =\n  (library: Library): PlainModulusDependencies =>\n  ({\n    Exception,\n    Modulus,\n    Vector\n  }: PlainModulusDependencyOptions): PlainModulusConstructorOptions =>\n  (): PlainModulus => {\n    // Static methods\n    const _Batching = library.PlainModulus.Batching\n    const _BatchingVector = library.PlainModulus.BatchingVector\n\n    /**\n     * @implements PlainModulus\n     */\n\n    /**\n     * @interface PlainModulus\n     */\n    return {\n      /**\n       * Creates a prime number PlainModulus for use as plainPlainModulus encryption\n       * parameter that supports batching with a given polyPlainModulusDegree.\n       *\n       * @function\n       * @name PlainModulus.Batching\n       * @param {number} polyModulusDegree The degree of the polynomial modulus\n       * @param {number} bitSize The bit-size of the desired prime number\n       * @returns {Modulus} A PlainModulus containing the prime number\n       */\n      Batching(polyModulusDegree: number, bitSize: number): Modulus {\n        try {\n          const smallMod = Modulus(BigInt(0))\n          smallMod.inject(_Batching(polyModulusDegree, bitSize))\n          return smallMod\n        } catch (e) {\n          throw Exception.safe(e as SealError)\n        }\n      },\n\n      /**\n       * Creates several prime number PlainModulus elements that can be used as\n       * plainPlainModulus encryption parameters, each supporting batching with a given\n       * polyPlainModulusDegree.\n       *\n       * @function\n       * @name PlainModulus.BatchingVector\n       * @param {Number} polyPlainModulusDegree The degree of the polynomial modulus\n       * @param {Int32Array} bitSizes Int32Array containing values representing bit-sizes of primes\n       * @returns {Vector} Vector of Modulus containing prime numbers\n       */\n      BatchingVector(\n        polyPlainModulusDegree: number,\n        bitSizes: Int32Array\n      ): Vector {\n        try {\n          const vectBitSizes = Vector()\n          vectBitSizes.from(bitSizes)\n          const vect = _BatchingVector(\n            polyPlainModulusDegree,\n            vectBitSizes.instance\n          )\n          vectBitSizes.delete()\n          return vect\n        } catch (e) {\n          throw Exception.safe(e as SealError)\n        }\n      }\n    }\n  }\n\nexport const PlainModulusInit = ({\n  loader\n}: LoaderOptions): PlainModulusDependencies => {\n  const library: Library = loader.library\n  return PlainModulusConstructor(library)\n}\n","import { ComprModeType } from './compr-mode-type'\nimport { INVALID_PLAIN_CONSRUCTOR_OPTIONS } from './constants'\nimport { Context } from './context'\nimport { Exception, SealError } from './exception'\nimport { MemoryPoolHandle } from './memory-pool-handle'\nimport { ParmsIdType, ParmsIdTypeConstructorOptions } from './parms-id-type'\nimport { Instance, Library, LoaderOptions } from './seal'\nimport { VectorConstructorOptions } from './vector'\nexport type PlainTextDependencyOptions = {\n  readonly Exception: Exception\n  readonly ComprModeType: ComprModeType\n  readonly ParmsIdType: ParmsIdTypeConstructorOptions\n  readonly MemoryPoolHandle: MemoryPoolHandle\n  readonly Vector: VectorConstructorOptions\n}\n\nexport type PlainTextDependencies = {\n  ({\n    Exception,\n    ComprModeType,\n    ParmsIdType,\n    MemoryPoolHandle,\n    Vector\n  }: PlainTextDependencyOptions): PlainTextConstructorOptions\n}\n\nexport type PlainTextConstructorOptions = {\n  ({\n    capacity,\n    coeffCount,\n    pool\n  }?: {\n    capacity?: number\n    coeffCount?: number\n    pool?: MemoryPoolHandle\n  }): PlainText\n}\n\nexport type PlainText = {\n  readonly instance: Instance\n  readonly unsafeInject: (instance: Instance) => void\n  readonly delete: () => void\n  readonly reserve: (capacity: number) => void\n  readonly shrinkToFit: () => void\n  readonly release: () => void\n  readonly resize: (coeffCount: number) => void\n  readonly setZero: () => void\n  readonly isZero: boolean\n  readonly capacity: number\n  readonly coeffCount: number\n  readonly significantCoeffCount: number\n  readonly nonzeroCoeffCount: number\n  readonly toPolynomial: () => string\n  readonly isNttForm: boolean\n  readonly parmsId: ParmsIdType\n  readonly scale: number\n  readonly setScale: (scale: number) => void\n  readonly pool: MemoryPoolHandle\n  readonly save: (compression?: ComprModeType) => string\n  readonly saveArray: (compression?: ComprModeType) => Uint8Array\n  readonly load: (context: Context, encoded: string) => void\n  readonly loadArray: (context: Context, array: Uint8Array) => void\n  readonly copy: (plain: PlainText) => void\n  readonly clone: () => PlainText\n  readonly move: (plain: PlainText) => void\n}\n\nconst PlainTextConstructor =\n  (library: Library): PlainTextDependencies =>\n  ({\n    Exception,\n    ComprModeType,\n    ParmsIdType,\n    MemoryPoolHandle,\n    Vector\n  }: PlainTextDependencyOptions): PlainTextConstructorOptions =>\n  ({\n    capacity,\n    coeffCount,\n    pool = MemoryPoolHandle.global\n  } = {}): PlainText => {\n    // Static methods\n    const Constructor = library.Plaintext\n\n    let _instance = construct({\n      capacity,\n      coeffCount,\n      pool\n    })\n\n    function construct({\n      capacity,\n      coeffCount,\n      pool = MemoryPoolHandle.global\n    }: {\n      capacity?: number\n      coeffCount?: number\n      pool?: MemoryPoolHandle\n    } = {}) {\n      try {\n        if (capacity === undefined && coeffCount === undefined) {\n          return new Constructor(pool)\n        } else if (capacity === undefined && coeffCount !== undefined) {\n          return new Constructor(coeffCount, pool)\n        } else if (capacity !== undefined && coeffCount !== undefined) {\n          return new Constructor(capacity, coeffCount, pool)\n        } else {\n          throw new Error(INVALID_PLAIN_CONSRUCTOR_OPTIONS)\n        }\n      } catch (e) {\n        throw Exception.safe(e as SealError)\n      }\n    }\n    /**\n     * @implements PlainText\n     */\n\n    /**\n     * @interface PlainText\n     */\n    return {\n      /**\n       * Get the underlying WASM instance\n       *\n       * @private\n       * @readonly\n       * @name PlainText#instance\n       * @type {Instance}\n       */\n      get instance() {\n        return _instance\n      },\n\n      /**\n       * Inject this object with a raw WASM instance. No type checking is performed.\n       *\n       * @private\n       * @function\n       * @name PlainText#unsafeInject\n       * @param {Instance} instance WASM instance\n       */\n      unsafeInject(instance: Instance) {\n        if (_instance) {\n          _instance.delete()\n          _instance = undefined\n        }\n        _instance = instance\n      },\n\n      /**\n       * Delete the underlying WASM instance.\n       *\n       * Should be called before dereferencing this object to prevent the\n       * WASM heap from growing indefinitely.\n       * @function\n       * @name PlainText#delete\n       */\n      delete() {\n        if (_instance) {\n          _instance.delete()\n          _instance = undefined\n        }\n      },\n\n      /**\n       * Allocates enough memory to accommodate the backing array of a plaintext\n       * with given capacity.\n       *\n       * @function\n       * @name PlainText#reserve\n       * @param {number} capacity The capacity to reserve\n       */\n      reserve(capacity: number) {\n        try {\n          return _instance.reserve(capacity)\n        } catch (e) {\n          throw Exception.safe(e as SealError)\n        }\n      },\n\n      /**\n       * Allocates enough memory to accommodate the backing array of the current\n       * PlainText and copies it over to the new location. This function is meant\n       * to reduce the memory use of the PlainText to smallest possible and can be\n       * particularly important after modulus switching.\n       *\n       * @function\n       * @name PlainText#shrinkToFit\n       */\n      shrinkToFit() {\n        _instance.shrinkToFit()\n      },\n\n      /**\n       * Resets the PlainText. This function releases any memory allocated by the\n       * PlainText, returning it to the memory pool.\n       *\n       * @function\n       * @name PlainText#release\n       */\n      release() {\n        _instance.release()\n      },\n\n      /**\n       * Resizes the PlainText to have a given coefficient count. The PlainText\n       * is automatically reallocated if the new coefficient count does not fit in\n       * the current capacity.\n       *\n       * @function\n       * @name PlainText#resize\n       * @param {number} coeffCount The number of coefficients in the plaintext polynomial\n       */\n      resize(coeffCount: number) {\n        try {\n          _instance.resize(coeffCount)\n        } catch (e) {\n          throw Exception.safe(e as SealError)\n        }\n      },\n\n      /**\n       * Sets the PlainText polynomial to zero.\n       *\n       * @function\n       * @name PlainText#setZero\n       */\n      setZero() {\n        _instance.setZero()\n      },\n\n      /**\n       * Whether the current PlainText polynomial has all zero coefficients.\n       *\n       * @readonly\n       * @name PlainText#isZero\n       * @type {boolean}\n       */\n      get isZero() {\n        return _instance.isZero()\n      },\n\n      /**\n       * The capacity of the current allocation.\n       *\n       * @readonly\n       * @name PlainText#capacity\n       * @type {number}\n       */\n      get capacity() {\n        return _instance.capacity()\n      },\n\n      /**\n       * The coefficient count of the current PlainText polynomial.\n       *\n       * @readonly\n       * @name PlainText#coeffCount\n       * @type {number}\n       */\n      get coeffCount() {\n        return _instance.coeffCount()\n      },\n\n      /**\n       * The significant coefficient count of the current PlainText polynomial.\n       *\n       * @readonly\n       * @name PlainText#significantCoeffCount\n       * @type {number}\n       */\n      get significantCoeffCount() {\n        return _instance.significantCoeffCount()\n      },\n\n      /**\n       * Returns the non-zero coefficient count of the current PlainText polynomial.\n       *\n       * @readonly\n       * @name PlainText#nonzeroCoeffCount\n       * @type {number}\n       */\n      get nonzeroCoeffCount() {\n        return _instance.nonzeroCoeffCount()\n      },\n\n      /**\n       * Returns a human-readable string description of the PlainText polynomial.\n       *\n       * The returned string is of the form \"7FFx^3 + 1x^1 + 3\" with a format\n       * summarized by the following:\n       * 1. Terms are listed in order of strictly decreasing exponent\n       * 2. Coefficient values are non-negative and in hexadecimal format (hexadecimal\n       * letters are in upper-case)\n       * 3. Exponents are positive and in decimal format\n       * 4. Zero coefficient terms (including the constant term) are omitted unless\n       * the polynomial is exactly 0 (see rule 9)\n       * 5. Term with the exponent value of one is written as x^1\n       * 6. Term with the exponent value of zero (the constant term) is written as\n       * just a hexadecimal number without x or exponent\n       * 7. Terms are separated exactly by <space>+<space>\n       * 8. Other than the +, no other terms have whitespace\n       * 9. If the polynomial is exactly 0, the string \"0\" is returned\n       *\n       * @function\n       * @name PlainText#toPolynomial\n       * @throws std::invalid_argument if the PlainText is in NTT transformed form\n       * @returns {string} Polynomial string\n       */\n      toPolynomial(): string {\n        try {\n          return _instance.toPolynomial()\n        } catch (e) {\n          throw Exception.safe(e as SealError)\n        }\n      },\n\n      /**\n       * Whether the PlainText is in NTT form.\n       *\n       * @readonly\n       * @name PlainText#isNttForm\n       * @type {boolean}\n       */\n      get isNttForm() {\n        return _instance.isNttForm()\n      },\n\n      /**\n       * The reference to parmsId of the PlainText. The parmsId must remain zero unless the\n       * PlainText polynomial is in NTT form.\n       *\n       * @see {@link EncryptionParameters} for more information about parmsId.\n       *\n       * @readonly\n       * @name PlainText#parmsId\n       * @type {ParmsIdType}\n       */\n      get parmsId() {\n        const parms = ParmsIdType()\n        parms.inject(_instance.parmsId())\n        return parms\n      },\n\n      /**\n       * The reference to the scale. This is only needed when using the CKKS\n       * encryption scheme. The user should have little or no reason to ever change\n       * the scale by hand.\n       *\n       * @readonly\n       * @name PlainText#scale\n       * @type {number}\n       */\n      get scale() {\n        return _instance.scale()\n      },\n\n      /**\n       * Sets the PlainText scale. This is only needed when using the\n       * CKKS encryption scheme. The user should have little or no reason to ever\n       * change the scale by hand.\n       *\n       * @function\n       * @name PlainText#setScale\n       * @param {number} scale The scale to set\n       */\n      setScale(scale: number) {\n        _instance.setScale(scale)\n      },\n\n      /**\n       * The currently used MemoryPoolHandle.\n       *\n       * @readonly\n       * @name PlainText#pool\n       * @type {MemoryPoolHandle}\n       */\n      get pool() {\n        return _instance.pool()\n      },\n\n      /**\n       * Save the PlainText to a base64 string\n       *\n       * @function\n       * @name PlainText#save\n       * @param {ComprModeType} [compression={@link ComprModeType.zstd}] The compression mode to use\n       * @returns {string} Base64 encoded string\n       */\n      save(compression: ComprModeType = ComprModeType.zstd): string {\n        return _instance.saveToString(compression)\n      },\n\n      /**\n       * Save the PlainText as a binary Uint8Array\n       *\n       * @function\n       * @name PlainText#saveArray\n       * @param {ComprModeType} [compression={@link ComprModeType.zstd}] The compression mode to use\n       * @returns {Uint8Array} A byte array containing the PlainText in binary form\n       */\n      saveArray(compression: ComprModeType = ComprModeType.zstd): Uint8Array {\n        const tempVect = Vector()\n        const instance = _instance.saveToArray(compression)\n        tempVect.unsafeInject(instance)\n        tempVect.setType('Uint8Array')\n        const tempArr = tempVect.toArray() as Uint8Array\n        tempVect.delete()\n        return tempArr\n      },\n\n      /**\n       * Load a PlainText from a base64 string\n       *\n       * @function\n       * @name PlainText#load\n       * @param {Context} context Encryption context to enforce\n       * @param {string} encoded Base64 encoded string\n       */\n      load(context: Context, encoded: string) {\n        try {\n          _instance.loadFromString(context.instance, encoded)\n        } catch (e) {\n          throw Exception.safe(e as SealError)\n        }\n      },\n\n      /**\n       * Load a PlainText from an Uint8Array holding binary data\n       *\n       * @function\n       * @name PlainText#loadArray\n       * @param {Context} context Encryption context to enforce\n       * @param {Uint8Array} array TypedArray containing binary data\n       */\n      loadArray(context: Context, array: Uint8Array) {\n        try {\n          _instance.loadFromArray(context.instance, array)\n        } catch (e) {\n          throw Exception.safe(e as SealError)\n        }\n      },\n\n      /**\n       * Copy an existing PlainText and overwrite this instance\n       *\n       * @function\n       * @name PlainText#copy\n       * @param {PlainText} plain PlainText to copy\n       * @example\n       * const plainTextA = seal.PlainText()\n       * // ... after encoding some data ...\n       * const plainTextB = seal.PlainText()\n       * plainTextB.copy(plainTextA)\n       * // plainTextB holds a copy of plainTextA\n       */\n      copy(plain: PlainText) {\n        try {\n          _instance.copy(plain.instance)\n        } catch (e) {\n          throw Exception.safe(e as SealError)\n        }\n      },\n\n      /**\n       * Clone and return a new instance of this PlainText\n       *\n       * @function\n       * @name PlainText#clone\n       * @returns {PlainText}\n       * @example\n       * const plainTextA = seal.PlainText()\n       * // ... after encoding some data ...\n       * const plainTextB = plainTextA.clone()\n       * // plainTextB holds a copy of plainTextA\n       */\n      clone(): PlainText {\n        try {\n          const clonedInstance = _instance.clone()\n          const plain = PlainTextConstructor(library)({\n            Exception,\n            ComprModeType,\n            ParmsIdType,\n            MemoryPoolHandle,\n            Vector\n          })()\n          plain.unsafeInject(clonedInstance)\n          return plain\n        } catch (e) {\n          throw Exception.safe(e as SealError)\n        }\n      },\n\n      /**\n       * Move a PlainText into this one and delete the old reference\n       *\n       * @function\n       * @name PlainText#move\n       * @param {PlainText} plain PlainText to move\n       * @example\n       * const plainTextA = seal.PlainText()\n       * // ... after encoding some data ...\n       * const plainTextB = seal.PlainText()\n       * plainTextB.move(plainTextA)\n       * // plainTextB holds a the instance of plainTextA.\n       * // plainTextA no longer holds an instance\n       */\n      move(plain: PlainText) {\n        try {\n          _instance.move(plain.instance)\n          // TODO: find optimization\n          // This method results in a copy instead of a real move.\n          // Therefore, we need to delete the old instance.\n          plain.delete()\n        } catch (e) {\n          throw Exception.safe(e as SealError)\n        }\n      }\n    }\n  }\n\nexport const PlainTextInit = ({\n  loader\n}: LoaderOptions): PlainTextDependencies => {\n  const library: Library = loader.library\n  return PlainTextConstructor(library)\n}\n","import { ComprModeType } from './compr-mode-type'\nimport { Context } from './context'\nimport { Exception, SealError } from './exception'\nimport { Instance, Library, LoaderOptions } from './seal'\nimport { VectorConstructorOptions } from './vector'\n\nexport type PublicKeyDependencyOptions = {\n  readonly Exception: Exception\n  readonly ComprModeType: ComprModeType\n  readonly Vector: VectorConstructorOptions\n}\n\nexport type PublicKeyDependencies = {\n  ({\n    Exception,\n    ComprModeType,\n    Vector\n  }: PublicKeyDependencyOptions): PublicKeyConstructorOptions\n}\n\nexport type PublicKeyConstructorOptions = {\n  (): PublicKey\n}\n\nexport type PublicKey = {\n  readonly instance: Instance\n  readonly inject: (instance: Instance) => void\n  readonly delete: () => void\n  readonly save: (compression?: ComprModeType) => string\n  readonly saveArray: (compression?: ComprModeType) => Uint8Array\n  readonly load: (context: Context, encoded: string) => void\n  readonly loadArray: (context: Context, array: Uint8Array) => void\n  readonly copy: (key: PublicKey) => void\n  readonly clone: () => PublicKey\n  readonly move: (key: PublicKey) => void\n}\n\nconst PublicKeyConstructor =\n  (library: Library): PublicKeyDependencies =>\n  ({\n    Exception,\n    ComprModeType,\n    Vector\n  }: PublicKeyDependencyOptions): PublicKeyConstructorOptions =>\n  (): PublicKey => {\n    const Constructor = library.PublicKey\n    let _instance = new Constructor()\n\n    /**\n     * @implements PublicKey\n     */\n\n    /**\n     * @interface PublicKey\n     */\n    return {\n      /**\n       * Get the underlying WASM instance\n       *\n       * @private\n       * @readonly\n       * @name PublicKey#instance\n       * @type {Instance}\n       */\n      get instance() {\n        return _instance\n      },\n\n      /**\n       * Inject this object with a raw WASM instance\n       *\n       * @private\n       * @function\n       * @name PublicKey#inject\n       * @param {Instance} instance WASM instance\n       */\n      inject(instance: Instance) {\n        if (_instance) {\n          _instance.delete()\n          _instance = undefined\n        }\n        _instance = new Constructor(instance)\n        instance.delete()\n      },\n\n      /**\n       * Delete the underlying WASM instance.\n       *\n       * Should be called before dereferencing this object to prevent the\n       * WASM heap from growing indefinitely.\n       * @function\n       * @name PublicKey#delete\n       */\n      delete() {\n        if (_instance) {\n          _instance.delete()\n          _instance = undefined\n        }\n      },\n\n      /**\n       * Save the Encryption Parameters to a base64 string\n       *\n       * @function\n       * @name PublicKey#save\n       * @param {ComprModeType} [compression={@link ComprModeType.zstd}] The compression mode to use\n       * @returns {string} Base64 encoded string\n       */\n      save(compression: ComprModeType = ComprModeType.zstd): string {\n        try {\n          return _instance.saveToString(compression)\n        } catch (e) {\n          throw Exception.safe(e as SealError)\n        }\n      },\n\n      /**\n       * Save the PublicKey as a binary Uint8Array\n       *\n       * @function\n       * @name PublicKey#saveArray\n       * @param {ComprModeType} [compression={@link ComprModeType.zstd}] The compression mode to use\n       * @returns {Uint8Array} A byte array containing the PublicKey in binary form\n       */\n      saveArray(compression: ComprModeType = ComprModeType.zstd): Uint8Array {\n        const tempVect = Vector()\n        const instance = _instance.saveToArray(compression)\n        tempVect.unsafeInject(instance)\n        tempVect.setType('Uint8Array')\n        const tempArr = tempVect.toArray() as Uint8Array\n        tempVect.delete()\n        return tempArr\n      },\n\n      /**\n       * Load a PublicKey from a base64 string\n       *\n       * @function\n       * @name PublicKey#load\n       * @param {Context} context Encryption context to enforce\n       * @param {string} encoded Base64 encoded string\n       */\n      load(context: Context, encoded: string) {\n        try {\n          _instance.loadFromString(context.instance, encoded)\n        } catch (e) {\n          throw Exception.safe(e as SealError)\n        }\n      },\n\n      /**\n       * Load a PublicKey from an Uint8Array holding binary data\n       *\n       * @function\n       * @name PublicKey#loadArray\n       * @param {Context} context Encryption context to enforce\n       * @param {Uint8Array} array TypedArray containing binary data\n       */\n      loadArray(context: Context, array: Uint8Array) {\n        try {\n          _instance.loadFromArray(context.instance, array)\n        } catch (e) {\n          throw Exception.safe(e as SealError)\n        }\n      },\n\n      /**\n       * Copy an existing PublicKey and overwrite this instance\n       *\n       * @function\n       * @name PublicKey#copy\n       * @param {PublicKey} key PublicKey to copy\n       * @example\n       * const keyA = keyGenerator.createPublicKey()\n       * const keyB = seal.PublicKey()\n       * keyB.copy(keyA)\n       * // keyB holds a copy of keyA\n       */\n      copy(key: PublicKey) {\n        try {\n          _instance.copy(key.instance)\n        } catch (e) {\n          throw Exception.safe(e as SealError)\n        }\n      },\n\n      /**\n       * Clone and return a new instance of this PublicKey\n       *\n       * @function\n       * @name PublicKey#clone\n       * @returns {PublicKey}\n       * @example\n       * const keyA = keyGenerator.createPublicKey()\n       * const keyB = keyA.clone()\n       * // keyB holds a copy of keyA\n       */\n      clone(): PublicKey {\n        try {\n          const clonedInstance = _instance.clone()\n          const key = PublicKeyConstructor(library)({\n            Exception,\n            ComprModeType,\n            Vector\n          })()\n          key.inject(clonedInstance)\n          return key\n        } catch (e) {\n          throw Exception.safe(e as SealError)\n        }\n      },\n\n      /**\n       * Move a PublicKey into this one and delete the old reference\n       *\n       * @function\n       * @name PublicKey#move\n       * @param {PublicKey} key PublicKey to move\n       * @example\n       * const keyA = keyGenerator.createPublicKey()\n       * const keyB = seal.PublicKey()\n       * keyB.move(keyA)\n       * // keyB holds a the instance of keyA.\n       * // keyA no longer holds an instance\n       */\n      move(key: PublicKey) {\n        try {\n          _instance.move(key.instance)\n          // TODO: find optimization\n          // This method results in a copy instead of a real move.\n          // Therefore, we need to delete the old instance.\n          key.delete()\n        } catch (e) {\n          throw Exception.safe(e as SealError)\n        }\n      }\n    }\n  }\n\nexport const PublicKeyInit = ({\n  loader\n}: LoaderOptions): PublicKeyDependencies => {\n  const library: Library = loader.library\n  return PublicKeyConstructor(library)\n}\n","import { ComprModeType } from './compr-mode-type'\nimport { Context } from './context'\nimport { Exception, SealError } from './exception'\nimport { Instance, Library, LoaderOptions } from './seal'\nimport { VectorConstructorOptions } from './vector'\n\nexport type RelinKeysDependencyOptions = {\n  readonly Exception: Exception\n  readonly ComprModeType: ComprModeType\n  readonly Vector: VectorConstructorOptions\n}\n\nexport type RelinKeysDependencies = {\n  ({\n    Exception,\n    ComprModeType,\n    Vector\n  }: RelinKeysDependencyOptions): RelinKeysConstructorOptions\n}\n\nexport type RelinKeysConstructorOptions = {\n  (): RelinKeys\n}\n\nexport type RelinKeys = {\n  readonly instance: Instance\n  readonly inject: (instance: Instance) => void\n  readonly delete: () => void\n  readonly size: number\n  readonly getIndex: (keyPower: number) => number\n  readonly hasKey: (keyPower: number) => boolean\n  readonly save: (compression?: ComprModeType) => string\n  readonly saveArray: (compression?: ComprModeType) => Uint8Array\n  readonly load: (context: Context, encoded: string) => void\n  readonly loadArray: (context: Context, array: Uint8Array) => void\n  readonly copy: (key: RelinKeys) => void\n  readonly clone: () => RelinKeys\n  readonly move: (key: RelinKeys) => void\n}\n\nconst RelinKeysConstructor =\n  (library: Library): RelinKeysDependencies =>\n  ({\n    Exception,\n    ComprModeType,\n    Vector\n  }: RelinKeysDependencyOptions): RelinKeysConstructorOptions =>\n  (): RelinKeys => {\n    const Constructor = library.RelinKeys\n    let _instance = new Constructor()\n\n    /**\n     * @implements RelinKeys\n     */\n\n    /**\n     * @interface RelinKeys\n     */\n    return {\n      /**\n       * Get the underlying WASM instance\n       *\n       * @private\n       * @readonly\n       * @name RelinKeys#instance\n       * @type {Instance}\n       */\n      get instance() {\n        return _instance\n      },\n\n      /**\n       * Inject this object with a raw WASM instance\n       *\n       * @private\n       * @function\n       * @name RelinKeys#inject\n       * @param {Instance} instance WASM instance\n       */\n      inject(instance: Instance) {\n        if (_instance) {\n          _instance.delete()\n          _instance = undefined\n        }\n        _instance = new Constructor(instance)\n        instance.delete()\n      },\n\n      /**\n       * Delete the underlying WASM instance.\n       *\n       * Should be called before dereferencing this object to prevent the\n       * WASM heap from growing indefinitely.\n       * @function\n       * @name RelinKeys#delete\n       */\n      delete() {\n        if (_instance) {\n          _instance.delete()\n          _instance = undefined\n        }\n      },\n\n      /**\n       * Returns the current number of keyswitching keys. Only keys that are\n       * non-empty are counted.\n       *\n       * @readonly\n       * @name RelinKeys#size\n       * @type {number}\n       */\n      get size() {\n        return _instance.size()\n      },\n\n      /**\n       * Returns the index of a relinearization key in the backing KSwitchKeys\n       * instance that corresponds to the given secret key power, assuming that\n       * it exists in the backing KSwitchKeys.\n       *\n       * @function\n       * @name RelinKeys#getIndex\n       * @param {number} keyPower The power of the secret key\n       * @returns {number} The index of the relin key\n       */\n      getIndex(keyPower: number): number {\n        try {\n          return _instance.getIndex(keyPower)\n        } catch (e) {\n          throw Exception.safe(e as SealError)\n        }\n      },\n\n      /**\n       * Returns whether a relinearization key corresponding to a given power of\n       * the secret key exists.\n       *\n       * @function\n       * @name RelinKeys#hasKey\n       * @param {number} keyPower The power of the secret key\n       * @returns {boolean} True if the power exists\n       */\n      hasKey(keyPower: number): boolean {\n        try {\n          return _instance.hasKey(keyPower)\n        } catch (e) {\n          throw Exception.safe(e as SealError)\n        }\n      },\n\n      /**\n       * Save the Encryption Parameters to a base64 string\n       *\n       * @function\n       * @name RelinKeys#save\n       * @param {ComprModeType} [compression={@link ComprModeType.zstd}] The compression mode to use\n       * @returns {string} Base64 encoded string\n       */\n      save(compression: ComprModeType = ComprModeType.zstd): string {\n        try {\n          return _instance.saveToString(compression)\n        } catch (e) {\n          throw Exception.safe(e as SealError)\n        }\n      },\n\n      /**\n       * Save the RelinKeys as a binary Uint8Array\n       *\n       * @function\n       * @name RelinKeys#saveArray\n       * @param {ComprModeType} [compression={@link ComprModeType.zstd}] The compression mode to use\n       * @returns {Uint8Array} A byte array containing the RelinKeys in binary form\n       */\n      saveArray(compression: ComprModeType = ComprModeType.zstd): Uint8Array {\n        const tempVect = Vector()\n        const instance = _instance.saveToArray(compression)\n        tempVect.unsafeInject(instance)\n        tempVect.setType('Uint8Array')\n        const tempArr = tempVect.toArray() as Uint8Array\n        tempVect.delete()\n        return tempArr\n      },\n\n      /**\n       * Load a RelinKeys from a base64 string\n       *\n       * @function\n       * @name RelinKeys#load\n       * @param {Context} context Encryption context to enforce\n       * @param {string} encoded Base64 encoded string\n       */\n      load(context: Context, encoded: string) {\n        try {\n          _instance.loadFromString(context.instance, encoded)\n        } catch (e) {\n          throw Exception.safe(e as SealError)\n        }\n      },\n\n      /**\n       * Load a RelinKeys from an Uint8Array holding binary data\n       *\n       * @function\n       * @name RelinKeys#loadArray\n       * @param {Context} context Encryption context to enforce\n       * @param {Uint8Array} array TypedArray containing binary data\n       */\n      loadArray(context: Context, array: Uint8Array) {\n        try {\n          _instance.loadFromArray(context.instance, array)\n        } catch (e) {\n          throw Exception.safe(e as SealError)\n        }\n      },\n\n      /**\n       * Copy an existing RelinKeys and overwrite this instance\n       *\n       * @function\n       * @name RelinKeys#copy\n       * @param {RelinKeys} key RelinKeys to copy\n       * @example\n       * const keyA = keyGenerator.createRelinKeys()\n       * const keyB = seal.RelinKeys()\n       * keyB.copy(keyA)\n       * // keyB holds a copy of keyA\n       */\n      copy(key: RelinKeys) {\n        try {\n          _instance.copy(key.instance)\n        } catch (e) {\n          throw Exception.safe(e as SealError)\n        }\n      },\n\n      /**\n       * Clone and return a new instance of this RelinKeys\n       *\n       * @function\n       * @name RelinKeys#clone\n       * @returns {RelinKeys}\n       * @example\n       * const keyA = keyGenerator.createRelinKeys()\n       * const keyB = keyA.clone()\n       * // keyB holds a copy of keyA\n       */\n      clone(): RelinKeys {\n        try {\n          const clonedInstance = _instance.clone()\n          const key = RelinKeysConstructor(library)({\n            Exception,\n            ComprModeType,\n            Vector\n          })()\n          key.inject(clonedInstance)\n          return key\n        } catch (e) {\n          throw Exception.safe(e as SealError)\n        }\n      },\n\n      /**\n       * Move a RelinKeys into this one and delete the old reference\n       *\n       * @function\n       * @name RelinKeys#move\n       * @param {RelinKeys} key RelinKeys to move\n       * @example\n       * const keyA = keyGenerator.createRelinKeys()\n       * const keyB = seal.RelinKeys()\n       * keyB.move(keyA)\n       * // keyB holds a the instance of keyA.\n       * // keyA no longer holds an instance\n       */\n      move(key: RelinKeys) {\n        try {\n          _instance.move(key.instance)\n          // TODO: find optimization\n          // This method results in a copy instead of a real move.\n          // Therefore, we need to delete the old instance.\n          key.delete()\n        } catch (e) {\n          throw Exception.safe(e as SealError)\n        }\n      }\n    }\n  }\n\nexport const RelinKeysInit = ({\n  loader\n}: LoaderOptions): RelinKeysDependencies => {\n  const library: Library = loader.library\n  return RelinKeysConstructor(library)\n}\n","import { Library, LoaderOptions } from './seal'\n\nexport type SchemeTypeDependencies = {\n  (): SchemeTypeConstructorOptions\n}\n\nexport type SchemeTypeConstructorOptions = {\n  (): SchemeType\n}\n\nexport type SchemeType = {\n  readonly none: any\n  readonly bfv: any\n  readonly ckks: any\n  readonly bgv: any\n}\n\nconst SchemeTypeConstructor =\n  (library: Library): SchemeTypeDependencies =>\n  (): SchemeTypeConstructorOptions =>\n  (): SchemeType => {\n    // Static methods\n    const _none = library.SchemeType.none\n    const _bfv = library.SchemeType.bfv\n    const _ckks = library.SchemeType.ckks\n    const _bgv = library.SchemeType.bgv\n\n    /**\n     * @implements SchemeType\n     */\n\n    /**\n     * @interface SchemeType\n     */\n    return {\n      /**\n       * Return the 'none' scheme type\n       *\n       * @readonly\n       * @name SchemeType.none\n       * @type {SchemeType.none}\n       */\n      get none() {\n        /**\n         * @typedef {SchemeType.none} SchemeType.none\n         */\n        return _none\n      },\n\n      /**\n       * Return the 'bfv' scheme type\n       *\n       * @readonly\n       * @name SchemeType.bfv\n       * @type {SchemeType.bfv}\n       */\n      get bfv() {\n        /**\n         * @typedef {SchemeType.bfv} SchemeType.bfv\n         */\n        return _bfv\n      },\n\n      /**\n       * Return the 'ckks' scheme type\n       *\n       * @readonly\n       * @name SchemeType.ckks\n       * @type {SchemeType.ckks}\n       */\n      get ckks() {\n        /**\n         * @typedef {SchemeType.ckks} SchemeType.ckks\n         */\n        return _ckks\n      },\n\n      /**\n       * Return the 'bgv' scheme type\n       *\n       * @readonly\n       * @name SchemeType.bgv\n       * @type {SchemeType.bgv}\n       */\n      get bgv() {\n        /**\n         * @typedef {SchemeType.bgv} SchemeType.bgv\n         */\n        return _bgv\n      }\n    }\n  }\n\nexport const SchemeTypeInit = ({\n  loader\n}: LoaderOptions): SchemeTypeDependencies => {\n  const library: Library = loader.library\n  return SchemeTypeConstructor(library)\n}\n","import { version } from '../../package.json'\nimport {\n  BatchEncoderConstructorOptions,\n  BatchEncoderDependencies\n} from './batch-encoder'\nimport {\n  CipherTextConstructorOptions,\n  CipherTextDependencies\n} from './cipher-text'\nimport {\n  CKKSEncoderConstructorOptions,\n  CKKSEncoderDependencies\n} from './ckks-encoder'\nimport { CoeffModulus, CoeffModulusDependencies } from './coeff-modulus'\nimport { ComprModeType, ComprModeTypeDependencies } from './compr-mode-type'\nimport { ContextConstructorOptions, ContextDependencies } from './context'\nimport {\n  ContextDataConstructorOptions,\n  ContextDataDependencies\n} from './context-data'\nimport { DecryptorConstructorOptions, DecryptorDependencies } from './decryptor'\nimport {\n  EncryptionParameterQualifiersConstructorOptions,\n  EncryptionParameterQualifiersDependencies\n} from './encryption-parameter-qualifiers'\nimport {\n  EncryptionParametersConstructorOptions,\n  EncryptionParametersDependencies\n} from './encryption-parameters'\nimport { EncryptorConstructorOptions, EncryptorDependencies } from './encryptor'\nimport { EvaluatorConstructorOptions, EvaluatorDependencies } from './evaluator'\nimport { Exception, ExceptionDependencies } from './exception'\nimport {\n  GaloisKeysConstructorOptions,\n  GaloisKeysDependencies\n} from './galois-keys'\nimport {\n  KeyGeneratorConstructorOptions,\n  KeyGeneratorDependencies\n} from './key-generator'\nimport {\n  MemoryPoolHandle,\n  MemoryPoolHandleDependencies\n} from './memory-pool-handle'\nimport { ModulusConstructorOptions, ModulusDependencies } from './modulus'\nimport {\n  ParmsIdTypeConstructorOptions,\n  ParmsIdTypeDependencies\n} from './parms-id-type'\nimport { PlainModulus, PlainModulusDependencies } from './plain-modulus'\nimport {\n  PlainTextConstructorOptions,\n  PlainTextDependencies\n} from './plain-text'\nimport {\n  PublicKeyConstructorOptions,\n  PublicKeyDependencies\n} from './public-key'\nimport {\n  RelinKeysConstructorOptions,\n  RelinKeysDependencies\n} from './relin-keys'\nimport { SchemeType, SchemeTypeDependencies } from './scheme-type'\nimport {\n  SecretKeyConstructorOptions,\n  SecretKeyDependencies\n} from './secret-key'\nimport { SecurityLevel, SecurityLevelDependencies } from './security-level'\nimport {\n  SerializableConstructorOptions,\n  SerializableDependencies\n} from './serializable'\nimport { VectorConstructorOptions, VectorDependencies } from './vector'\n\nexport type Instance = any\nexport type Loader = any\nexport type Library = any\nexport type Dependencies = any\nexport type LoaderOptions = {\n  readonly loader: Loader\n}\n\nexport type SEALLibrary = {\n  readonly BatchEncoder: BatchEncoderConstructorOptions\n  readonly CipherText: CipherTextConstructorOptions\n  readonly CKKSEncoder: CKKSEncoderConstructorOptions\n  readonly CoeffModulus: CoeffModulus\n  readonly ComprModeType: ComprModeType\n  readonly ContextData: ContextDataConstructorOptions\n  readonly Context: ContextConstructorOptions\n  readonly Decryptor: DecryptorConstructorOptions\n  readonly EncryptionParameterQualifiers: EncryptionParameterQualifiersConstructorOptions\n  readonly EncryptionParameters: EncryptionParametersConstructorOptions\n  readonly Encryptor: EncryptorConstructorOptions\n  readonly Evaluator: EvaluatorConstructorOptions\n  readonly Exception: Exception\n  readonly GaloisKeys: GaloisKeysConstructorOptions\n  readonly KeyGenerator: KeyGeneratorConstructorOptions\n  readonly MemoryPoolHandle: MemoryPoolHandle\n  readonly Modulus: ModulusConstructorOptions\n  readonly ParmsIdType: ParmsIdTypeConstructorOptions\n  readonly PlainText: PlainTextConstructorOptions\n  readonly PlainModulus: PlainModulus\n  readonly PublicKey: PublicKeyConstructorOptions\n  readonly RelinKeys: RelinKeysConstructorOptions\n  readonly SchemeType: SchemeType\n  readonly SecretKey: SecretKeyConstructorOptions\n  readonly SecurityLevel: SecurityLevel\n  readonly Serializable: SerializableConstructorOptions\n  readonly Vector: VectorConstructorOptions\n  readonly Version: string\n}\ntype SEALConstructorOptions = {\n  readonly BatchEncoder: BatchEncoderDependencies\n  readonly CipherText: CipherTextDependencies\n  readonly CKKSEncoder: CKKSEncoderDependencies\n  readonly CoeffModulus: CoeffModulusDependencies\n  readonly ComprModeType: ComprModeTypeDependencies\n  readonly ContextData: ContextDataDependencies\n  readonly Context: ContextDependencies\n  readonly Decryptor: DecryptorDependencies\n  readonly EncryptionParameterQualifiers: EncryptionParameterQualifiersDependencies\n  readonly EncryptionParameters: EncryptionParametersDependencies\n  readonly Encryptor: EncryptorDependencies\n  readonly Evaluator: EvaluatorDependencies\n  readonly Exception: ExceptionDependencies\n  readonly GaloisKeys: GaloisKeysDependencies\n  readonly KeyGenerator: KeyGeneratorDependencies\n  readonly MemoryPoolHandle: MemoryPoolHandleDependencies\n  readonly Modulus: ModulusDependencies\n  readonly ParmsIdType: ParmsIdTypeDependencies\n  readonly PlainText: PlainTextDependencies\n  readonly PlainModulus: PlainModulusDependencies\n  readonly PublicKey: PublicKeyDependencies\n  readonly RelinKeys: RelinKeysDependencies\n  readonly SchemeType: SchemeTypeDependencies\n  readonly SecretKey: SecretKeyDependencies\n  readonly SecurityLevel: SecurityLevelDependencies\n  readonly Serializable: SerializableDependencies\n  readonly Vector: VectorDependencies\n}\n\n/**\n * @implements SEAL\n */\nexport const SEALConstructor = ({\n  BatchEncoder,\n  CipherText,\n  CKKSEncoder,\n  CoeffModulus,\n  ComprModeType,\n  ContextData,\n  Context,\n  Decryptor,\n  EncryptionParameterQualifiers,\n  EncryptionParameters,\n  Encryptor,\n  Evaluator,\n  Exception,\n  GaloisKeys,\n  KeyGenerator,\n  MemoryPoolHandle,\n  Modulus,\n  ParmsIdType,\n  PlainText,\n  PlainModulus,\n  PublicKey,\n  RelinKeys,\n  SchemeType,\n  SecretKey,\n  SecurityLevel,\n  Serializable,\n  Vector\n}: SEALConstructorOptions): SEALLibrary => {\n  // Unfortunately, this library has nested depenencies\n  // so we need to load them in order.\n\n  // Define our singletons\n  const exception = Exception()()\n  const comprModeType = ComprModeType()()\n  const memoryPoolHandle = MemoryPoolHandle()()\n  const securityLevel = SecurityLevel()()\n  const schemeType = SchemeType()()\n\n  // Define our constructors (ORDER MATTERS)\n  const vector = Vector({ Exception: exception })\n  const coeffModulus = CoeffModulus({\n    Exception: exception,\n    SecurityLevel: securityLevel,\n    Vector: vector\n  })()\n  const modulus = Modulus({\n    Exception: exception,\n    ComprModeType: comprModeType,\n    Vector: vector\n  })\n  const plainModulus = PlainModulus({\n    Exception: exception,\n    Modulus: modulus,\n    Vector: vector\n  })()\n  const serializable = Serializable({\n    Exception: exception,\n    Vector: vector,\n    ComprModeType: comprModeType\n  })\n  const parmsIdType = ParmsIdType({ Exception: exception })\n  const plainText = PlainText({\n    Exception: exception,\n    ComprModeType: comprModeType,\n    ParmsIdType: parmsIdType,\n    MemoryPoolHandle: memoryPoolHandle,\n    Vector: vector\n  })\n  const cipherText = CipherText({\n    Exception: exception,\n    ComprModeType: comprModeType,\n    ParmsIdType: parmsIdType,\n    MemoryPoolHandle: memoryPoolHandle,\n    Vector: vector\n  })\n  const batchEncoder = BatchEncoder({\n    Exception: exception,\n    MemoryPoolHandle: memoryPoolHandle,\n    PlainText: plainText,\n    Vector: vector\n  })\n  const ckksEncoder = CKKSEncoder({\n    Exception: exception,\n    MemoryPoolHandle: memoryPoolHandle,\n    PlainText: plainText,\n    Vector: vector\n  })\n  const encryptionParameterQualifiers = EncryptionParameterQualifiers()\n  const encryptionParameters = EncryptionParameters({\n    Exception: exception,\n    ComprModeType: comprModeType,\n    Modulus: modulus,\n    SchemeType: schemeType,\n    ParmsIdType: parmsIdType,\n    Vector: vector\n  })\n  const contextData = ContextData({\n    Exception: exception,\n    EncryptionParameters: encryptionParameters,\n    ParmsIdType: parmsIdType,\n    EncryptionParameterQualifiers: encryptionParameterQualifiers\n  })\n  const context = Context({\n    ParmsIdType: parmsIdType,\n    ContextData: contextData,\n    SecurityLevel: securityLevel\n  })\n  const decryptor = Decryptor({\n    Exception: exception,\n    PlainText: plainText\n  })\n  const encryptor = Encryptor({\n    Exception: exception,\n    MemoryPoolHandle: memoryPoolHandle,\n    CipherText: cipherText,\n    Serializable: serializable\n  })\n  const evaluator = Evaluator({\n    Exception: exception,\n    MemoryPoolHandle: memoryPoolHandle,\n    CipherText: cipherText,\n    PlainText: plainText\n  })\n  const publicKey = PublicKey({\n    Exception: exception,\n    ComprModeType: comprModeType,\n    Vector: vector\n  })\n  const secretKey = SecretKey({\n    Exception: exception,\n    ComprModeType: comprModeType,\n    Vector: vector\n  })\n  const relinKeys = RelinKeys({\n    Exception: exception,\n    ComprModeType: comprModeType,\n    Vector: vector\n  })\n  const galoisKeys = GaloisKeys({\n    Exception: exception,\n    ComprModeType: comprModeType,\n    Vector: vector\n  })\n  const keyGenerator = KeyGenerator({\n    Exception: exception,\n    PublicKey: publicKey,\n    SecretKey: secretKey,\n    RelinKeys: relinKeys,\n    GaloisKeys: galoisKeys,\n    Serializable: serializable\n  })\n\n  /**\n   * @interface SEAL\n   */\n  return {\n    BatchEncoder: batchEncoder,\n    CipherText: cipherText,\n    CKKSEncoder: ckksEncoder,\n    CoeffModulus: coeffModulus, // Singleton\n    ComprModeType: comprModeType, // Singleton\n    ContextData: contextData,\n    Context: context,\n    Decryptor: decryptor,\n    EncryptionParameterQualifiers: encryptionParameterQualifiers,\n    EncryptionParameters: encryptionParameters,\n    Encryptor: encryptor,\n    Evaluator: evaluator,\n    Exception: exception, // Singleton\n    GaloisKeys: galoisKeys,\n    KeyGenerator: keyGenerator,\n    MemoryPoolHandle: memoryPoolHandle, // Singleton\n    Modulus: modulus,\n    ParmsIdType: parmsIdType,\n    PlainText: plainText,\n    PlainModulus: plainModulus, // Singleton\n    PublicKey: publicKey,\n    RelinKeys: relinKeys,\n    SchemeType: schemeType,\n    SecretKey: secretKey,\n    SecurityLevel: securityLevel, // Singleton\n    Serializable: serializable,\n    Vector: vector,\n    Version: version\n  }\n}\n","import { ComprModeType } from './compr-mode-type'\nimport { Context } from './context'\nimport { Exception, SealError } from './exception'\nimport { Instance, Library, LoaderOptions } from './seal'\nimport { VectorConstructorOptions } from './vector'\n\nexport type SecretKeyDependencyOptions = {\n  readonly Exception: Exception\n  readonly ComprModeType: ComprModeType\n  readonly Vector: VectorConstructorOptions\n}\n\nexport type SecretKeyDependencies = {\n  ({\n    Exception,\n    ComprModeType,\n    Vector\n  }: SecretKeyDependencyOptions): SecretKeyConstructorOptions\n}\n\nexport type SecretKeyConstructorOptions = {\n  (): SecretKey\n}\n\nexport type SecretKey = {\n  readonly instance: Instance\n  readonly inject: (instance: Instance) => void\n  readonly delete: () => void\n  readonly save: (compression?: ComprModeType) => string\n  readonly saveArray: (compression?: ComprModeType) => Uint8Array\n  readonly load: (context: Context, encoded: string) => void\n  readonly loadArray: (context: Context, array: Uint8Array) => void\n  readonly copy: (key: SecretKey) => void\n  readonly clone: () => SecretKey\n  readonly move: (key: SecretKey) => void\n}\n\nconst SecretKeyConstructor =\n  (library: Library): SecretKeyDependencies =>\n  ({\n    Exception,\n    ComprModeType,\n    Vector\n  }: SecretKeyDependencyOptions): SecretKeyConstructorOptions =>\n  (): SecretKey => {\n    const Constructor = library.SecretKey\n    let _instance = new Constructor()\n\n    /**\n     * @implements SecretKey\n     */\n\n    /**\n     * @interface SecretKey\n     */\n    return {\n      /**\n       * Get the underlying WASM instance\n       *\n       * @private\n       * @readonly\n       * @name SecretKey#instance\n       * @type {Instance}\n       */\n      get instance() {\n        return _instance\n      },\n\n      /**\n       * Inject this object with a raw WASM instance\n       *\n       * @private\n       * @function\n       * @name SecretKey#inject\n       * @param {Instance} instance WASM instance\n       */\n      inject(instance: Instance) {\n        if (_instance) {\n          _instance.delete()\n          _instance = undefined\n        }\n        _instance = new Constructor(instance)\n        instance.delete()\n      },\n\n      /**\n       * Delete the underlying WASM instance.\n       *\n       * Should be called before dereferencing this object to prevent the\n       * WASM heap from growing indefinitely.\n       * @function\n       * @name SecretKey#delete\n       */\n      delete() {\n        if (_instance) {\n          _instance.delete()\n          _instance = undefined\n        }\n      },\n\n      /**\n       * Save the Encryption Parameters to a base64 string\n       *\n       * @function\n       * @name SecretKey#save\n       * @param {ComprModeType} [compression={@link ComprModeType.zstd}] The compression mode to use\n       * @returns {string} Base64 encoded string\n       */\n      save(compression: ComprModeType = ComprModeType.zstd): string {\n        try {\n          return _instance.saveToString(compression)\n        } catch (e) {\n          throw Exception.safe(e as SealError)\n        }\n      },\n\n      /**\n       * Save the SecretKey as a binary Uint8Array\n       *\n       * @function\n       * @name SecretKey#saveArray\n       * @param {ComprModeType} [compression={@link ComprModeType.zstd}] The compression mode to use\n       * @returns {Uint8Array} A byte array containing the SecretKey in binary form\n       */\n      saveArray(compression: ComprModeType = ComprModeType.zstd): Uint8Array {\n        const tempVect = Vector()\n        const instance = _instance.saveToArray(compression)\n        tempVect.unsafeInject(instance)\n        tempVect.setType('Uint8Array')\n        const tempArr = tempVect.toArray() as Uint8Array\n        tempVect.delete()\n        return tempArr\n      },\n\n      /**\n       * Load a SecretKey from a base64 string\n       *\n       * @function\n       * @name SecretKey#load\n       * @param {Context} context Encryption context to enforce\n       * @param {string} encoded Base64 encoded string\n       */\n      load(context: Context, encoded: string) {\n        try {\n          _instance.loadFromString(context.instance, encoded)\n        } catch (e) {\n          throw Exception.safe(e as SealError)\n        }\n      },\n\n      /**\n       * Load a SecretKey from an Uint8Array holding binary data\n       *\n       * @function\n       * @name SecretKey#loadArray\n       * @param {Context} context Encryption context to enforce\n       * @param {Uint8Array} array TypedArray containing binary data\n       */\n      loadArray(context: Context, array: Uint8Array) {\n        try {\n          _instance.loadFromArray(context.instance, array)\n        } catch (e) {\n          throw Exception.safe(e as SealError)\n        }\n      },\n\n      /**\n       * Copy an existing SecretKey and overwrite this instance\n       *\n       * @function\n       * @name SecretKey#copy\n       * @param {SecretKey} key SecretKey to copy\n       * @example\n       * const keyA = keyGenerator.secretKey()\n       * const keyB = seal.SecretKey()\n       * keyB.copy(keyA)\n       * // keyB holds a copy of keyA\n       */\n      copy(key: SecretKey) {\n        try {\n          _instance.copy(key.instance)\n        } catch (e) {\n          throw Exception.safe(e as SealError)\n        }\n      },\n\n      /**\n       * Clone and return a new instance of this SecretKey\n       *\n       * @function\n       * @name SecretKey#clone\n       * @returns {SecretKey}\n       * @example\n       * const keyA = keyGenerator.secretKey()\n       * const keyB = keyA.clone()\n       * // keyB holds a copy of keyA\n       */\n      clone(): SecretKey {\n        try {\n          const clonedInstance = _instance.clone()\n          const key = SecretKeyConstructor(library)({\n            Exception,\n            ComprModeType,\n            Vector\n          })()\n          key.inject(clonedInstance)\n          return key\n        } catch (e) {\n          throw Exception.safe(e as SealError)\n        }\n      },\n\n      /**\n       * Move a SecretKey into this one and delete the old reference\n       *\n       * @function\n       * @name SecretKey#move\n       * @param {SecretKey} key SecretKey to move\n       * @example\n       * const keyA = keyGenerator.secretKey()\n       * const keyB = seal.SecretKey()\n       * keyB.move(keyA)\n       * // keyB holds a the instance of keyA.\n       * // keyA no longer holds an instance\n       */\n      move(key: SecretKey) {\n        try {\n          _instance.move(key.instance)\n          // TODO: find optimization\n          // This method results in a copy instead of a real move.\n          // Therefore, we need to delete the old instance.\n          key.delete()\n        } catch (e) {\n          throw Exception.safe(e as SealError)\n        }\n      }\n    }\n  }\n\nexport const SecretKeyInit = ({\n  loader\n}: LoaderOptions): SecretKeyDependencies => {\n  const library: Library = loader.library\n  return SecretKeyConstructor(library)\n}\n","import { Library, LoaderOptions } from './seal'\n\nexport type SecurityLevelDependencies = {\n  (): SecurityLevelConstructorOptions\n}\n\nexport type SecurityLevelConstructorOptions = {\n  (): SecurityLevel\n}\n\nexport type SecurityLevel = {\n  readonly none: any\n  readonly tc128: any\n  readonly tc192: any\n  readonly tc256: any\n}\n\nconst SecurityLevelConstructor =\n  (library: Library): SecurityLevelDependencies =>\n  (): SecurityLevelConstructorOptions =>\n  (): SecurityLevel => {\n    // Static methods\n    const _none = library.SecLevelType.none\n    const _tc128 = library.SecLevelType.tc128\n    const _tc192 = library.SecLevelType.tc192\n    const _tc256 = library.SecLevelType.tc256\n\n    /**\n     * @implements SecurityLevel\n     */\n\n    /**\n     * @interface SecurityLevel\n     */\n    return {\n      /**\n       * Returns the 'none' security level\n       *\n       * @readonly\n       * @name SecurityLevel.none\n       * @type {SecurityLevel.none}\n       */\n      get none() {\n        /**\n         * @typedef {SecurityLevel.none} SecurityLevel.none\n         */\n        return _none\n      },\n\n      /**\n       * Returns the '128' security level\n       *\n       * @readonly\n       * @name SecurityLevel.tc128\n       * @type {SecurityLevel.tc128}\n       */\n      get tc128() {\n        /**\n         * @typedef {SecurityLevel.tc128} SecurityLevel.tc128\n         */\n        return _tc128\n      },\n\n      /**\n       * Returns the '192' security level\n       *\n       * @readonly\n       * @name SecurityLevel.tc192\n       * @type {SecurityLevel.tc192}\n       */\n      get tc192() {\n        /**\n         * @typedef {SecurityLevel.tc192} SecurityLevel.tc192\n         */\n        return _tc192\n      },\n\n      /**\n       * Returns the '256' security level\n       *\n       * @readonly\n       * @name SecurityLevel.tc256\n       * @type {SecurityLevel.tc256}\n       */\n      get tc256() {\n        /**\n         * @typedef {SecurityLevel.tc256} SecurityLevel.tc256\n         */\n        return _tc256\n      }\n    }\n  }\nexport const SecurityLevelInit = ({\n  loader\n}: LoaderOptions): SecurityLevelDependencies => {\n  const library: Library = loader.library\n  return SecurityLevelConstructor(library)\n}\n","import { INSTANCE_DELETED, UNSUPPORTED_VECTOR_TYPE } from './constants'\nimport { Exception, SealError } from './exception'\nimport { Instance, Library, LoaderOptions } from './seal'\n\nexport type VectorDependencyOptions = {\n  readonly Exception: Exception\n}\n\nexport type VectorDependencies = {\n  ({ Exception }: VectorDependencyOptions): VectorConstructorOptions\n}\n\nexport type VectorConstructorOptions = {\n  (): Vector\n}\n\nexport type Vector = {\n  readonly instance: Instance\n  readonly unsafeInject: (instance: Instance) => void\n  readonly delete: () => void\n  readonly from: (array: VectorTypes, type?: StringTypes) => Instance\n  readonly type: string\n  readonly setType: (type: StringTypes) => void\n  readonly size: number\n  readonly getValue: (index: number) => number\n  readonly resize: (size: number, fill: number) => void\n  readonly toArray: () => VectorTypes\n}\n\nexport type VectorTypes =\n  | Uint8Array\n  | Int32Array\n  | Uint32Array\n  | Float64Array\n  | BigInt64Array\n  | BigUint64Array\n\nexport type StringTypes =\n  | 'Uint8Array'\n  | 'Int32Array'\n  | 'Uint32Array'\n  | 'Float64Array'\n  | 'BigInt64Array'\n  | 'BigUint64Array'\n  | 'Modulus'\n\nconst VectorConstructor =\n  (library: Library): VectorDependencies =>\n  ({ Exception }: VectorDependencyOptions): VectorConstructorOptions =>\n  (): Vector => {\n    // Static methods\n    const _vecFromArrayUint8 = library.vecFromArrayUint8\n    const _vecFromArrayUint32 = library.vecFromArrayUint32\n    const _vecFromArrayInt32 = library.vecFromArrayInt32\n    const _vecFromArrayFloat64 = library.vecFromArrayFloat64\n    const _vecFromArrayBigInt64 = library.vecFromArrayBigInt64\n    const _vecFromArrayBigUint64 = library.vecFromArrayBigUint64\n    const _vecFromArrayModulus = library.vecFromArrayModulus\n    const _jsArrayUint8FromVec = library.jsArrayUint8FromVec\n    const _jsArrayUint32FromVec = library.jsArrayUint32FromVec\n    const _jsArrayInt32FromVec = library.jsArrayInt32FromVec\n    const _jsArrayFloat64FromVec = library.jsArrayFloat64FromVec\n    const _jsArrayStringFromVecInt64 = library.jsArrayStringFromVecInt64\n    const _jsArrayStringFromVecUint64 = library.jsArrayStringFromVecUint64\n    const _jsArrayStringFromVecModulus = library.jsArrayStringFromVecModulus\n\n    let _instance: Instance\n    let _type: StringTypes\n    /**\n     * @implements Vector\n     */\n\n    /**\n     * @interface Vector\n     */\n    return {\n      /**\n       * Get the underlying WASM instance\n       *\n       * @private\n       * @readonly\n       * @name Vector#instance\n       * @type {Instance}\n       */\n      get instance() {\n        return _instance\n      },\n\n      /**\n       * Inject this object with a raw WASM instance. No type checking is performed.\n       *\n       * @private\n       * @function\n       * @name Vector#unsafeInject\n       * @param {Instance} instance WASM instance\n       */\n      unsafeInject(instance: Instance) {\n        if (_instance) {\n          _instance.delete()\n          _instance = undefined\n        }\n        _instance = instance\n      },\n\n      /**\n       * Delete the underlying WASM instance.\n       *\n       * Should be called before dereferencing this object to prevent the\n       * WASM heap from growing indefinitely.\n       * @function\n       * @name Vector#delete\n       */\n      delete() {\n        if (_instance) {\n          _instance.delete()\n          _instance = undefined\n        }\n      },\n\n      /**\n       * Converts a JS TypedArray into a vector\n       *\n       * @function\n       * @name Vector#from\n       * @param {VectorTypes} array The TypedArray to convert\n       * @param {StringTypes} [type] An optional type override - useful for 'Modulus' only\n       */\n      from(array: VectorTypes, type?: StringTypes) {\n        try {\n          _type = type ? type : (array.constructor.name as StringTypes)\n          switch (_type) {\n            case 'Uint8Array':\n              _instance = _vecFromArrayUint8(array)\n              break\n            case 'Int32Array':\n              _instance = _vecFromArrayInt32(array)\n              break\n            case 'Uint32Array':\n              _instance = _vecFromArrayUint32(array)\n              break\n            case 'Float64Array':\n              _instance = _vecFromArrayFloat64(array)\n              break\n            case 'BigInt64Array':\n              _instance = _vecFromArrayBigInt64(array.toString().split(','))\n              break\n            case 'BigUint64Array':\n              _instance = _vecFromArrayBigUint64(array.toString().split(','))\n              break\n            case 'Modulus':\n              _instance = _vecFromArrayModulus(array.toString().split(','))\n              break\n            default:\n              throw new Error(UNSUPPORTED_VECTOR_TYPE)\n          }\n        } catch (e) {\n          throw Exception.safe(e as SealError)\n        }\n      },\n\n      /**\n       * The Vector type\n       *\n       * @readonly\n       * @name Vector#type\n       */\n      get type(): StringTypes {\n        return _type\n      },\n\n      /**\n       * Set the Vector type\n       *\n       * @function\n       * @name Vector#setType\n       * @param {StringTypes} type the type of the vector\n       */\n      setType(type: StringTypes) {\n        _type = type\n      },\n\n      /**\n       * The vector size\n       *\n       * @readonly\n       * @name Vector#size\n       * @type {number}\n       */\n      get size(): number {\n        return _instance.size()\n      },\n\n      /**\n       * Get a value pointed to by the specified index\n       *\n       * @function\n       * @name Vector#getValue\n       * @param {number} index Index of the Vector\n       * @returns {number} Value of the element in the Vector pointed to by the index\n       */\n      getValue(index: number): number {\n        try {\n          return _instance.get(index)\n        } catch (e) {\n          throw Exception.safe(e as SealError)\n        }\n      },\n\n      /**\n       * Resizes a vector to the given size\n       *\n       * @function\n       * @name Vector#resize\n       * @param {number} size number of elements to resize\n       * @param {number} fill Data to fill the vector with\n       */\n      resize(size: number, fill: number) {\n        try {\n          _instance.resize(size, fill)\n        } catch (e) {\n          throw Exception.safe(e as SealError)\n        }\n      },\n\n      /**\n       * Copy a vector's data into a Typed Array\n       *\n       * Note: we cannot simply return a view on the underlying ArrayBuffer\n       * because WASM memory can grow and cause all the views to become\n       * neutered. We have to perform a hard copy to get data from WASM heap to JS.\n       *\n       * @function\n       * @name Vector#toArray\n       * @returns {VectorTypes} TypedArray containing values from the Vector\n       */\n      toArray(): VectorTypes {\n        if (!_instance) {\n          throw new Error(INSTANCE_DELETED)\n        }\n        switch (_type) {\n          case 'Uint8Array':\n            return Uint8Array.from(_jsArrayUint8FromVec(_instance))\n          case 'Int32Array':\n            return Int32Array.from(_jsArrayInt32FromVec(_instance))\n          case 'Uint32Array':\n            return Uint32Array.from(_jsArrayUint32FromVec(_instance))\n          case 'Float64Array':\n            return Float64Array.from(_jsArrayFloat64FromVec(_instance))\n          case 'BigInt64Array':\n            return BigInt64Array.from(_jsArrayStringFromVecInt64(_instance))\n          case 'BigUint64Array':\n            return BigUint64Array.from(_jsArrayStringFromVecUint64(_instance))\n          case 'Modulus':\n            return BigUint64Array.from(_jsArrayStringFromVecModulus(_instance))\n          default:\n            throw new Error(UNSUPPORTED_VECTOR_TYPE)\n        }\n      }\n    }\n  }\n\nexport const VectorInit = ({ loader }: LoaderOptions): VectorDependencies => {\n  const library: Library = loader.library\n  return VectorConstructor(library)\n}\n","import sealLibrary from 'seal_allows_wasm_cf_worker'\nimport { SEALLibrary } from './implementation/seal'\nimport { Loader, createLoader } from './main/loader'\nimport { SEAL } from './main/seal'\n\n/**\n * Main export for node-seal\n */\nexport default async (wasmBinary: WebAssembly.Module): Promise<SEALLibrary> => {\n    const library = await sealLibrary({\n        instantiateWasm(info: any, cb: any) {\n            const instance = new WebAssembly.Instance(wasmBinary, info);\n            cb(instance, wasmBinary)\n        }\n    });\n    return SEAL(async () => ({ library }))\n}\n","import { BatchEncoderInit } from '../implementation/batch-encoder'\nimport { CipherTextInit } from '../implementation/cipher-text'\nimport { CKKSEncoderInit } from '../implementation/ckks-encoder'\nimport { CoeffModulusInit } from '../implementation/coeff-modulus'\nimport { ComprModeTypeInit } from '../implementation/compr-mode-type'\nimport { ContextInit } from '../implementation/context'\nimport { ContextDataInit } from '../implementation/context-data'\nimport { DecryptorInit } from '../implementation/decryptor'\nimport { EncryptionParameterQualifiersInit } from '../implementation/encryption-parameter-qualifiers'\nimport { EncryptionParametersInit } from '../implementation/encryption-parameters'\nimport { EncryptorInit } from '../implementation/encryptor'\nimport { EvaluatorInit } from '../implementation/evaluator'\nimport { ExceptionInit } from '../implementation/exception'\nimport { GaloisKeysInit } from '../implementation/galois-keys'\nimport { KeyGeneratorInit } from '../implementation/key-generator'\nimport { MemoryPoolHandleInit } from '../implementation/memory-pool-handle'\nimport { ModulusInit } from '../implementation/modulus'\nimport { ParmsIdTypeInit } from '../implementation/parms-id-type'\nimport { PlainModulusInit } from '../implementation/plain-modulus'\nimport { PlainTextInit } from '../implementation/plain-text'\nimport { PublicKeyInit } from '../implementation/public-key'\nimport { RelinKeysInit } from '../implementation/relin-keys'\nimport { SchemeTypeInit } from '../implementation/scheme-type'\nimport { SEALConstructor, SEALLibrary } from '../implementation/seal'\nimport { SecretKeyInit } from '../implementation/secret-key'\nimport { SecurityLevelInit } from '../implementation/security-level'\nimport { SerializableInit } from '../implementation/serializable'\nimport { VectorInit } from '../implementation/vector'\nimport { Loader } from './loader'\n\n/**\n * Main export for the library\n */\nexport const SEAL = async (\n  Loader: () => Promise<Loader>\n): Promise<SEALLibrary> => {\n  const loader = await Loader()\n  return SEALConstructor({\n    BatchEncoder: BatchEncoderInit({\n      loader\n    }),\n    CipherText: CipherTextInit({\n      loader\n    }),\n    CKKSEncoder: CKKSEncoderInit({\n      loader\n    }),\n    CoeffModulus: CoeffModulusInit({\n      loader\n    }),\n    ComprModeType: ComprModeTypeInit({\n      loader\n    }),\n    ContextData: ContextDataInit({\n      loader\n    }),\n    Context: ContextInit({\n      loader\n    }),\n    Decryptor: DecryptorInit({\n      loader\n    }),\n    EncryptionParameterQualifiers: EncryptionParameterQualifiersInit(),\n    EncryptionParameters: EncryptionParametersInit({\n      loader\n    }),\n    Encryptor: EncryptorInit({\n      loader\n    }),\n    Evaluator: EvaluatorInit({\n      loader\n    }),\n    Exception: ExceptionInit({\n      loader\n    }),\n    GaloisKeys: GaloisKeysInit({\n      loader\n    }),\n    KeyGenerator: KeyGeneratorInit({\n      loader\n    }),\n    MemoryPoolHandle: MemoryPoolHandleInit({\n      loader\n    }),\n    Modulus: ModulusInit({\n      loader\n    }),\n    ParmsIdType: ParmsIdTypeInit({\n      loader\n    }),\n    PlainText: PlainTextInit({\n      loader\n    }),\n    PlainModulus: PlainModulusInit({\n      loader\n    }),\n    PublicKey: PublicKeyInit({\n      loader\n    }),\n    RelinKeys: RelinKeysInit({\n      loader\n    }),\n    SchemeType: SchemeTypeInit({\n      loader\n    }),\n    SecretKey: SecretKeyInit({\n      loader\n    }),\n    SecurityLevel: SecurityLevelInit({\n      loader\n    }),\n    Serializable: SerializableInit(),\n    Vector: VectorInit({\n      loader\n    })\n  })\n}\n","import { Instance } from './seal'\nimport { SecurityLevel } from './security-level'\n\nexport type EncryptionParameterQualifiersDependencies = {\n  (): EncryptionParameterQualifiersConstructorOptions\n}\n\nexport type EncryptionParameterQualifiersConstructorOptions = {\n  (): EncryptionParameterQualifiers\n}\n\nexport type EncryptionParameterQualifiers = {\n  readonly instance: Instance\n  readonly unsafeInject: (instance: Instance) => void\n  readonly delete: () => void\n  readonly parametersSet: () => boolean\n  readonly usingFFT: boolean\n  readonly usingNTT: boolean\n  readonly usingBatching: boolean\n  readonly usingFastPlainLift: boolean\n  readonly usingDescendingModulusChain: boolean\n  readonly securityLevel: SecurityLevel\n}\n\nconst EncryptionParameterQualifiersConstructor =\n  (): EncryptionParameterQualifiersDependencies =>\n  (): EncryptionParameterQualifiersConstructorOptions =>\n  (): EncryptionParameterQualifiers => {\n    let _instance: Instance\n    /**\n     * @implements EncryptionParameterQualifiers\n     */\n\n    /**\n     * @interface EncryptionParameterQualifiers\n     */\n    return {\n      /**\n       * Get the underlying WASM instance\n       *\n       * @private\n       * @readonly\n       * @name EncryptionParameterQualifiers#instance\n       * @type {Instance}\n       */\n      get instance() {\n        return _instance\n      },\n\n      /**\n       * Inject this object with a raw WASM instance. No type checking is performed.\n       *\n       * @private\n       * @function\n       * @name EncryptionParameterQualifiers#unsafeInject\n       * @param {Instance} instance WASM instance\n       */\n      unsafeInject(instance: Instance) {\n        if (_instance) {\n          _instance.delete()\n          _instance = undefined\n        }\n        _instance = instance\n      },\n\n      /**\n       * Delete the underlying WASM instance.\n       *\n       * Should be called before dereferencing this object to prevent the\n       * WASM heap from growing indefinitely.\n       * @function\n       * @name EncryptionParameterQualifiers#delete\n       */\n      delete() {\n        if (_instance) {\n          _instance.delete()\n          _instance = undefined\n        }\n      },\n\n      /**\n       * If the encryption parameters are set in a way that is considered valid by\n       * Microsoft SEAL, the variable parameters_set is set to true.\n       *\n       * @function\n       * @name EncryptionParameterQualifiers#parametersSet\n       * @type {boolean}\n       */\n      parametersSet() {\n        return _instance.parametersSet()\n      },\n\n      /**\n       * Tells whether FFT can be used for polynomial multiplication. If the\n       * polynomial modulus is of the form X^N+1, where N is a power of two, then\n       * FFT can be used for fast multiplication of polynomials modulo the polynomial\n       * modulus. In this case the variable using_fft will be set to true. However,\n       * currently Microsoft SEAL requires this to be the case for the parameters\n       * to be valid. Therefore, parameters_set can only be true if using_fft is\n       * true.\n       *\n       * @readonly\n       * @name EncryptionParameterQualifiers#usingFFT\n       * @type {boolean}\n       */\n      get usingFFT() {\n        return _instance.usingFFT\n      },\n\n      /**\n       * Tells whether NTT can be used for polynomial multiplication. If the primes\n       * in the coefficient modulus are congruent to 1 modulo 2N, where X^N+1 is the\n       * polynomial modulus and N is a power of two, then the number-theoretic\n       * transform (NTT) can be used for fast multiplications of polynomials modulo\n       * the polynomial modulus and coefficient modulus. In this case the variable\n       * using_ntt will be set to true. However, currently Microsoft SEAL requires\n       * this to be the case for the parameters to be valid. Therefore, parameters_set\n       * can only be true if using_ntt is true.\n       *\n       * @readonly\n       * @name EncryptionParameterQualifiers#usingNTT\n       * @type {boolean}\n       */\n      get usingNTT() {\n        return _instance.usingNTT\n      },\n\n      /**\n       * Tells whether batching is supported by the encryption parameters. If the\n       * plaintext modulus is congruent to 1 modulo 2N, where X^N+1 is the polynomial\n       * modulus and N is a power of two, then it is possible to use the BatchEncoder\n       * class to view plaintext elements as 2-by-(N/2) matrices of integers modulo\n       * the plaintext modulus. This is called batching, and allows the user to\n       * operate on the matrix elements (slots) in a SIMD fashion, and rotate the\n       * matrix rows and columns. When the computation is easily vectorizable, using\n       * batching can yield a huge performance boost. If the encryption parameters\n       * support batching, the variable using_batching is set to true.\n       *\n       * @readonly\n       * @name EncryptionParameterQualifiers#usingBatching\n       * @type {boolean}\n       */\n      get usingBatching() {\n        return _instance.usingBatching\n      },\n\n      /**\n       * Tells whether fast plain lift is supported by the encryption parameters.\n       * A certain performance optimization in multiplication of a ciphertext by\n       * a plaintext (Evaluator::multiply_plain) and in transforming a plaintext\n       * element to NTT domain (Evaluator::transform_to_ntt) can be used when the\n       * plaintext modulus is smaller than each prime in the coefficient modulus.\n       * In this case the variable using_fast_plain_lift is set to true.\n       *\n       * @readonly\n       * @name EncryptionParameterQualifiers#usingFastPlainLift\n       * @type {boolean}\n       */\n      get usingFastPlainLift() {\n        return _instance.usingFastPlainLift\n      },\n\n      /**\n       * Tells whether the coefficient modulus consists of a set of primes that\n       * are in decreasing order. If this is true, certain modular reductions in\n       * base conversion can be omitted, improving performance.\n       *\n       * @readonly\n       * @name EncryptionParameterQualifiers#usingDescendingModulusChain\n       * @type {boolean}\n       */\n      get usingDescendingModulusChain() {\n        return _instance.usingDescendingModulusChain\n      },\n\n      /**\n       * Tells whether the encryption parameters are secure based on the standard\n       * parameters from HomomorphicEncryption.org security standard.\n       *\n       * @readonly\n       * @name EncryptionParameterQualifiers#securityLevel\n       * @type {(SecurityLevel.none|SecurityLevel.tc128|SecurityLevel.tc192|SecurityLevel.tc256)}\n       */\n      get securityLevel() {\n        return _instance.securityLevel\n      }\n    }\n  }\n\nexport const EncryptionParameterQualifiersInit =\n  (): EncryptionParameterQualifiersDependencies => {\n    return EncryptionParameterQualifiersConstructor()\n  }\n","import { ComprModeType } from './compr-mode-type'\nimport { Exception, SealError } from './exception'\nimport { Instance } from './seal'\nimport { VectorConstructorOptions } from './vector'\n\nexport type SerializableDependencyOptions = {\n  readonly Exception: Exception\n  readonly Vector: VectorConstructorOptions\n  readonly ComprModeType: ComprModeType\n}\n\nexport type SerializableDependencies = {\n  ({\n    Exception,\n    Vector,\n    ComprModeType\n  }: SerializableDependencyOptions): SerializableConstructorOptions\n}\n\nexport type SerializableConstructorOptions = {\n  (): Serializable\n}\n\nexport type Serializable = {\n  readonly instance: Instance\n  readonly unsafeInject: (instance: Instance) => void\n  readonly delete: () => void\n  readonly save: (compression?: ComprModeType) => string\n  readonly saveArray: (compression?: ComprModeType) => Uint8Array\n}\n\nconst SerializableConstructor =\n  (): SerializableDependencies =>\n  ({\n    Exception,\n    Vector,\n    ComprModeType\n  }: SerializableDependencyOptions): SerializableConstructorOptions =>\n  (): Serializable => {\n    let _instance: Instance\n\n    /**\n     * @implements Serializable\n     */\n\n    /**\n     * @interface Serializable\n     */\n    return {\n      /**\n       * Get the underlying WASM instance\n       *\n       * @private\n       * @readonly\n       * @name Serializable#instance\n       * @type {Instance}\n       */\n      get instance() {\n        return _instance\n      },\n\n      /**\n       * Inject this object with a raw WASM instance. No type checking is performed.\n       *\n       * @private\n       * @function\n       * @name Serializable#unsafeInject\n       * @param {Instance} instance WASM instance\n       */\n      unsafeInject(instance: Instance) {\n        if (_instance) {\n          _instance.delete()\n          _instance = undefined\n        }\n        _instance = instance\n      },\n\n      /**\n       * Delete the underlying WASM instance.\n       *\n       * Should be called before dereferencing this object to prevent the\n       * WASM heap from growing indefinitely.\n       * @function\n       * @name Serializable#delete\n       */\n      delete() {\n        if (_instance) {\n          _instance.delete()\n          _instance = undefined\n        }\n      },\n\n      /**\n       * Save to a base64 string\n       *\n       * @function\n       * @name Serializable#save\n       * @param {ComprModeType} [compression={@link ComprModeType.zstd}] The compression mode to use\n       * @returns {string} Base64 encoded string\n       */\n      save(compression: ComprModeType = ComprModeType.zstd): string {\n        try {\n          return _instance.saveToString(compression)\n        } catch (e) {\n          throw Exception.safe(e as SealError)\n        }\n      },\n\n      /**\n       * Save as a binary Uint8Array\n       *\n       * @function\n       * @name Serializable#saveArray\n       * @param {ComprModeType} [compression={@link ComprModeType.zstd}] The compression mode to use\n       * @returns {Uint8Array} A byte array containing the Serializable object in binary form\n       */\n      saveArray(compression: ComprModeType = ComprModeType.zstd): Uint8Array {\n        const tempVect = Vector()\n        const instance = _instance.saveToArray(compression)\n        tempVect.unsafeInject(instance)\n        tempVect.setType('Uint8Array')\n        const tempArr = tempVect.toArray() as Uint8Array\n        tempVect.delete()\n        return tempArr\n      }\n    }\n  }\n\nexport const SerializableInit = (): SerializableDependencies => {\n  return SerializableConstructor()\n}\n"],"names":["Module","moduleArg","aa","ba","ha","ia","k","ca","Promise","a","b","da","ea","url","fa","URL","href","XMLHttpRequest","open","responseType","send","Uint8Array","response","async","fetch","credentials","ok","arrayBuffer","Error","status","u","w","ja","ka","z","A","B","D","E","la","ma","na","oa","q","console","error","bind","y","pa","buffer","Int8Array","Int16Array","Uint16Array","Int32Array","Uint32Array","Float32Array","Float64Array","BigInt64Array","BigUint64Array","ra","G","I","qa","onAbort","WebAssembly","RuntimeError","ta","c","sa","instantiate","d","va","name","constructor","this","message","wa","length","shift","xa","ya","za","preRun","push","Aa","Ba","X","Ea","J","K","L","Fa","M","super","N","hasOwnProperty","forEach","e","Ga","Ha","TypeError","Ja","V","Y","W","Ka","La","P","FinalizationRegistry","count","value","$","unregister","register","Na","Oa","Object","defineProperty","Pa","Qa","Z","apply","ga","Ra","Ta","f","h","g","Ua","Va","toString","Wa","Xa","clone","Q","Ya","Za","fromWireType","$a","ab","cb","db","create","writable","eb","l","n","m","toWireType","hb","fb","gb","ib","get","kb","jb","R","includes","lb","nb","mb","S","T","map","join","U","Array","ob","pop","qb","pb","p","r","x","t","v","F","rb","tb","trim","indexOf","slice","ub","vb","wb","Yb","xb","readValueFromPointer","yb","zb","Ab","Bb","assign","optional","charCodeAt","Cb","Db","TextDecoder","Eb","NaN","decode","subarray","String","fromCharCode","Fb","Gb","Hb","Ib","Jb","Kb","Lb","Mb","Nb","Ob","Pb","Qb","Tb","Reflect","construct","Ub","Vb","onExit","Xb","Zb","USER","LOGNAME","PATH","PWD","HOME","LANG","navigator","languages","replace","_","ac","crypto","getRandomValues","bc","cc","prototype","isAliasOf","getPrototypeOf","call","isDeleted","deleteLater","Symbol","dispose","ua","bb","pointerType","noExitRuntime","printErr","wasmBinary","thisProgram","fc","BigInt","asUintN","Sa","Ia","O","C","sb","keys","H","s","startsWith","substring","concat","enumerable","configurable","set","splice","className","values","o","ArrayBuffer","isView","BYTES_PER_ELEMENT","dc","Sb","Rb","i","j","clearTimeout","id","setTimeout","Wb","ec","performance","now","Ca","Date","getFullYear","getTimezoneOffset","Math","max","Number","abs","floor","padStart","min","ceil","byteLength","grow","Infinity","exports","_emscripten_stack_alloc","emscripten_stack_get_current","gc","monitorRunDependencies","instantiateWasm","locateFile","instantiateStreaming","instance","reject","hc","_main","preInit","ic","calledRun","onRuntimeInitialized","noInitialRun","postRun","setStatus","UNSUPPORTED_VECTOR_TYPE","BatchEncoderInit","loader","library","Exception","MemoryPoolHandle","PlainText","Vector","context","Constructor","BatchEncoder","_instance","safe","unsafeInject","delete","undefined","encode","array","plainText","plain","stringArray","split","signed","pool","global","tempVect","decodeInt32","setType","tempArr","toArray","decodeUint32","decodeBigInt","from","slotCount","BatchEncoderConstructor","CipherTextConstructor","ComprModeType","ParmsIdType","parmsId","sizeCapacity","Ciphertext","reserve","capacity","resize","size","release","coeffModulusSize","polyModulusDegree","isTransparent","isNttForm","parms","inject","scale","setScale","save","compression","zstd","saveToString","saveArray","saveToArray","load","encoded","loadFromString","loadArray","loadFromArray","copy","cipher","clonedInstance","move","CipherTextInit","CKKSEncoderInit","CKKSEncoder","decodeDouble","CKKSEncoderConstructor","CoeffModulusInit","SecurityLevel","_MaxBitCount","CoeffModulus","MaxBitCount","_BFVDefault","BFVDefault","_CreateFromArray","CreateFromArray","securityLevel","tc128","vectorModulus","Create","bitSizes","CoeffModulusConstructor","ComprModeTypeInit","_none","none","_zlib","zlib","_zstd","ComprModeTypeConstructor","ContextInit","ContextData","encryptionParams","expandModChain","SEALContext","toHuman","getContextData","contextData","keyContextData","firstContextData","lastContextData","parametersSet","keyParmsId","firstParmsId","lastParmsId","usingKeyswitching","ContextConstructor","ContextDataConstructor","EncryptionParameters","EncryptionParameterQualifiers","encryptionParameters","qualifiers","encParmQualifiers","totalCoeffModulusBitCount","prevContextData","cxtData","nextContextData","chainIndex","ContextDataInit","DecryptorInit","secretKey","Decryptor","decrypt","cipherText","invariantNoiseBudget","DecryptorConstructor","EncryptionParametersInit","Modulus","SchemeType","schemeType","setPolyModulusDegree","setCoeffModulus","coeffModulus","setPlainModulus","plainModulus","scheme","smallModulus","EncryptionParametersConstructor","EncryptorInit","CipherText","Serializable","publicKey","Encryptor","constructInstance","encrypt","encryptSerializable","temp","encryptSymmetric","encryptSymmetricSerializable","serialized","encryptZero","encryptZeroSerializable","EncryptorConstructor","EvaluatorInit","Evaluator","negate","encrypted","destination","add","sub","multiply","square","relinearize","relinKeys","cipherModSwitchToNext","cipherModSwitchTo","plainModSwitchToNext","plainModSwitchTo","rescaleToNext","rescaleTo","modReduceToNext","modReduceTo","exponentiate","exponent","addPlain","subPlain","multiplyPlain","plainTransformToNtt","destinationNtt","cipherTransformToNtt","cipherTransformFromNtt","encryptedNtt","applyGalois","galoisElt","galoisKeys","rotateRows","steps","rotateColumns","rotateVector","complexConjugate","sumElements","newDest","dotProduct","dotProductPlain","EvaluatorConstructor","ExceptionInit","_getException","getException","ExceptionConstructor","GaloisKeysConstructor","GaloisKeys","getIndex","hasKey","key","GaloisKeysInit","KeyGeneratorInit","PublicKey","SecretKey","RelinKeys","KeyGenerator","createPublicKey","createPublicKeySerializable","createRelinKeys","createRelinKeysSerializable","createGaloisKeys","createGaloisKeysSerializable","KeyGeneratorConstructor","MemoryPoolHandleInit","_global","MemoryPoolHandleGlobal","_threadLocal","MemoryPoolHandleThreadLocal","threadLocal","MemoryPoolHandleConstructor","ModulusInit","inst","setValue","createModulus","bitCount","isZero","isPrime","ModulusConstructor","ParmsIdTypeInit","ParmsIdTypeConstructor","PlainModulusInit","_Batching","PlainModulus","Batching","_BatchingVector","BatchingVector","bitSize","smallMod","polyPlainModulusDegree","vectBitSizes","vect","PlainModulusConstructor","PlainTextConstructor","coeffCount","Plaintext","shrinkToFit","setZero","significantCoeffCount","nonzeroCoeffCount","toPolynomial","PlainTextInit","PublicKeyConstructor","PublicKeyInit","RelinKeysConstructor","keyPower","RelinKeysInit","SchemeTypeInit","_bfv","bfv","_ckks","ckks","_bgv","bgv","SchemeTypeConstructor","SecretKeyConstructor","SecretKeyInit","SecurityLevelInit","SecLevelType","_tc128","_tc192","tc192","_tc256","tc256","SecurityLevelConstructor","VectorInit","_vecFromArrayUint8","vecFromArrayUint8","_vecFromArrayUint32","vecFromArrayUint32","_vecFromArrayInt32","vecFromArrayInt32","_vecFromArrayFloat64","vecFromArrayFloat64","_vecFromArrayBigInt64","vecFromArrayBigInt64","_vecFromArrayBigUint64","vecFromArrayBigUint64","_vecFromArrayModulus","vecFromArrayModulus","_jsArrayUint8FromVec","jsArrayUint8FromVec","_jsArrayUint32FromVec","jsArrayUint32FromVec","_jsArrayInt32FromVec","jsArrayInt32FromVec","_jsArrayFloat64FromVec","jsArrayFloat64FromVec","_jsArrayStringFromVecInt64","jsArrayStringFromVecInt64","_jsArrayStringFromVecUint64","jsArrayStringFromVecUint64","_jsArrayStringFromVecModulus","jsArrayStringFromVecModulus","_type","type","getValue","index","fill","VectorConstructor","allows_wasm_cf_worker_es","sealLibrary","info","Instance","Loader","Context","exception","comprModeType","memoryPoolHandle","vector","modulus","serializable","parmsIdType","batchEncoder","ckksEncoder","encryptionParameterQualifiers","decryptor","encryptor","evaluator","Version","SEALConstructor","usingFFT","usingNTT","usingBatching","usingFastPlainLift","usingDescendingModulusChain","SEAL"],"mappings":"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"}